{
    "docs": [
        {
            "location": "/", 
            "text": "Gishiki\n\n\nGishiki\n: a modern and elegant MVC framework for PHP \n= 5.4 and HHVM.\n\n\nGishiki means 'ritual' in japanese, this name was chosen because this framework will help you to perform the\nritual of creation and deployment of web digital contents.\n\n\nDue to its design this framework won't force you to use its features: you are completely free of using it as you wish,\neven if that breaks up MVC principles and/or uses a custom ORM.\n\n\nGishiki is so fast to deploy that you don't even need to configure it to get started!\n\n\nGive it a shot!\n\n\nYou want to try it, just to see if it really works, don't you?\n\n\nWell, to test it you need to \ninstall\n it!\n\n\nLicense\n\n\nGishiki is released under Apache-2.0 license terms, read the \nLICENSE\n to find out more!", 
            "title": "Home"
        }, 
        {
            "location": "/#gishiki", 
            "text": "Gishiki : a modern and elegant MVC framework for PHP  = 5.4 and HHVM.  Gishiki means 'ritual' in japanese, this name was chosen because this framework will help you to perform the\nritual of creation and deployment of web digital contents.  Due to its design this framework won't force you to use its features: you are completely free of using it as you wish,\neven if that breaks up MVC principles and/or uses a custom ORM.  Gishiki is so fast to deploy that you don't even need to configure it to get started!", 
            "title": "Gishiki"
        }, 
        {
            "location": "/#give-it-a-shot", 
            "text": "You want to try it, just to see if it really works, don't you?  Well, to test it you need to  install  it!", 
            "title": "Give it a shot!"
        }, 
        {
            "location": "/#license", 
            "text": "Gishiki is released under Apache-2.0 license terms, read the  LICENSE  to find out more!", 
            "title": "License"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nInstalling Gishiki is really simple, even a child could be able to do it:\nhowever, in order to succeed you need to complete some steps.\n\n\nYou don't have to follow all the reported steps: you setup your environment,\nyour composer installation (local and/or remote) and presto!\n\n\nWindows\n\n\nYou may want to test Gishiki or develop your application on Windows:\nto install the application on windows you should install \nXAMPP\n and enable PDO drivers on php.ini. \n\n\nMac OS X\n\n\nIf you are willing to develop your application on a Mac system you should use\n\nXAMPP\n too!\n\n\nLinux\n\n\nEvery production server runs on a linux or a container inside linux, this is why\nevery instruction you'll find are written for linux (Ubuntu 14.04/15.04 LTS).\n\n\nVirtual Machine\n\n\nIf you don't want to pollute your desktop environment you can use a virtualization\nprogram, like \nVirtualBox\n, to install \nUbuntu Server\n and\nfollow the tutorial on that virtual machine!\n\n\nLet's go!\n\n\nIf you are a newcomer I suggest you to follow the PHP 7.0 \n nginx tutorial I have written for you.\n\n\nIf you want something that works in a few seconds than the \nPaaS\n page\nis the right manual page!", 
            "title": "Environment"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "Installing Gishiki is really simple, even a child could be able to do it:\nhowever, in order to succeed you need to complete some steps.  You don't have to follow all the reported steps: you setup your environment,\nyour composer installation (local and/or remote) and presto!", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#windows", 
            "text": "You may want to test Gishiki or develop your application on Windows:\nto install the application on windows you should install  XAMPP  and enable PDO drivers on php.ini.", 
            "title": "Windows"
        }, 
        {
            "location": "/installation/#mac-os-x", 
            "text": "If you are willing to develop your application on a Mac system you should use XAMPP  too!", 
            "title": "Mac OS X"
        }, 
        {
            "location": "/installation/#linux", 
            "text": "Every production server runs on a linux or a container inside linux, this is why\nevery instruction you'll find are written for linux (Ubuntu 14.04/15.04 LTS).", 
            "title": "Linux"
        }, 
        {
            "location": "/installation/#virtual-machine", 
            "text": "If you don't want to pollute your desktop environment you can use a virtualization\nprogram, like  VirtualBox , to install  Ubuntu Server  and\nfollow the tutorial on that virtual machine!", 
            "title": "Virtual Machine"
        }, 
        {
            "location": "/installation/#lets-go", 
            "text": "If you are a newcomer I suggest you to follow the PHP 7.0   nginx tutorial I have written for you.  If you want something that works in a few seconds than the  PaaS  page\nis the right manual page!", 
            "title": "Let's go!"
        }, 
        {
            "location": "/installation/basic_php/", 
            "text": "Basic PHP\n\n\nYou \nhave to\n download and install PHP on your development environment and on\nyour production server.\n\n\nYou don't need a webserver, nor a database manager, nor a graylog2 server:\nyou \nonly\n need PHP version 5.6 or greater!\n\n\nPHP Webserver\n\n\nYou may not want to install a webserver in you development machine, but you might\nwant to test your products by yourself and locally before performing the push/deploy.\n\n\nYou can test your products by starting the PHP own's webserver:\n\n\nphp -S localhost:8080 -t ./\n\n\n\n\nThis feature is meant for testing purpouse because it is IDE friendly and easy to\nuse without an ide, but you \nshould avoid\n using PHP webserver in production!", 
            "title": "Basic PHP"
        }, 
        {
            "location": "/installation/basic_php/#basic-php", 
            "text": "You  have to  download and install PHP on your development environment and on\nyour production server.  You don't need a webserver, nor a database manager, nor a graylog2 server:\nyou  only  need PHP version 5.6 or greater!", 
            "title": "Basic PHP"
        }, 
        {
            "location": "/installation/basic_php/#php-webserver", 
            "text": "You may not want to install a webserver in you development machine, but you might\nwant to test your products by yourself and locally before performing the push/deploy.  You can test your products by starting the PHP own's webserver:  php -S localhost:8080 -t ./  This feature is meant for testing purpouse because it is IDE friendly and easy to\nuse without an ide, but you  should avoid  using PHP webserver in production!", 
            "title": "PHP Webserver"
        }, 
        {
            "location": "/installation/php_7_nginx/", 
            "text": "PHP v7 \n nginx\n\n\nThis framework is fully compatible with PHP 7, and you are encouraged to use it.\n\n\nPHP v7 is the PHP version I am using while developing Gishiki.\n\n\nInstallation depends on your system, so read the PHP manual (or google for instructions....).\n\n\nYou will be provided with ubuntu instructions:\n\n\nsudo add-apt-repository ppa:ondrej/php\nsudo apt-get update\nsudo apt-get install -y language-pack-en-base\nsudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php\nsudo apt-get install nginx php7.0 php7.0-dev php7.0-xml php7.0-fpm php7.0-mysql php7.0-sqlite php7.0-pgsql php7.0-curl\n\n\n\n\nWhen you are done with the configuration file (/etc/nginx/sites-enabled/default), \nwhich should be basically:\n\n\nserver {\n    listen 80;\n    server_name site.com;\n    root /var/www/html/Gishiki;\n\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        # NOTE: You should have \ncgi.fix_pathinfo = 0;\n in php.ini\n\n        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; # this is important (YOU MUST CHECK FOR THIS FILE!)\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_intercept_errors on;\n    }\n}\n\n\n\n\nyou restart the server and the php service:\n\n\nsudo service nginx restart\nsudo service php7.0-fpm restart\n\n\n\n\nAnd the server should just work!", 
            "title": "PHP 7.0 & nginx"
        }, 
        {
            "location": "/installation/php_7_nginx/#php-v7-nginx", 
            "text": "This framework is fully compatible with PHP 7, and you are encouraged to use it.  PHP v7 is the PHP version I am using while developing Gishiki.  Installation depends on your system, so read the PHP manual (or google for instructions....).  You will be provided with ubuntu instructions:  sudo add-apt-repository ppa:ondrej/php\nsudo apt-get update\nsudo apt-get install -y language-pack-en-base\nsudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php\nsudo apt-get install nginx php7.0 php7.0-dev php7.0-xml php7.0-fpm php7.0-mysql php7.0-sqlite php7.0-pgsql php7.0-curl  When you are done with the configuration file (/etc/nginx/sites-enabled/default), \nwhich should be basically:  server {\n    listen 80;\n    server_name site.com;\n    root /var/www/html/Gishiki;\n\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        # NOTE: You should have  cgi.fix_pathinfo = 0;  in php.ini\n\n        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; # this is important (YOU MUST CHECK FOR THIS FILE!)\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_intercept_errors on;\n    }\n}  you restart the server and the php service:  sudo service nginx restart\nsudo service php7.0-fpm restart  And the server should just work!", 
            "title": "PHP v7 &amp; nginx"
        }, 
        {
            "location": "/installation/basic_nginx/", 
            "text": "Basic nginx\n\n\nYou may want to use nginx.... That's legit and smart, but you already know how to \ndo your job, so just remember to enable PHP and the rewriting engine:\n\n\nserver {\n    listen 80;\n    server_name site.com;\n    root /var/www/html;\n        error_log /var/www/error.log;\n        access_log /var/www/access.log;\n\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        # NOTE: You should have \ncgi.fix_pathinfo = 0;\n in php.ini\n\n        fastcgi_pass unix:/var/run/php5-fpm.sock;\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_intercept_errors on;\n    }\n}\n\n\n\n\nYour server configuration file should be located at /etc/nginx/nginx.conf", 
            "title": "Basic nginx"
        }, 
        {
            "location": "/installation/basic_nginx/#basic-nginx", 
            "text": "You may want to use nginx.... That's legit and smart, but you already know how to \ndo your job, so just remember to enable PHP and the rewriting engine:  server {\n    listen 80;\n    server_name site.com;\n    root /var/www/html;\n        error_log /var/www/error.log;\n        access_log /var/www/access.log;\n\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        # NOTE: You should have  cgi.fix_pathinfo = 0;  in php.ini\n\n        fastcgi_pass unix:/var/run/php5-fpm.sock;\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_intercept_errors on;\n    }\n}  Your server configuration file should be located at /etc/nginx/nginx.conf", 
            "title": "Basic nginx"
        }, 
        {
            "location": "/installation/basic_apache/", 
            "text": "Basic Apache 2.4\n\n\nIf you are using a debian or ubuntu based distro you have to remember that you\nneed to enable mod_rewrite on apache:\n\n\nsudo a2enmod rewrite\nsudo nano /etc/apache2/sites-available/000-default.conf\nsudo service apache2 restart\n\n\n\n\nYou must have AllowOverride set to \"All\" and not to \"None\" in the file being edited by nano.\n\n\nWhen you are done with nano just ctrl+O, Enter, ctrl+X.\n\n\nYou can simply cut 'n' paste this configuration:\n\n\nVirtualHost *:80\n\n    #ServerName www.example.com\n\n    ServerAdmin webmaster@localhost\n    DocumentRoot /var/www/html\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n        # globally allow .htaccess\n    \nDirectory \n/var/www/html\n\n        AllowOverride All\n    \n/Directory\n\n\n/VirtualHost\n\n\n# vim: syntax=apache ts=4 sw=4 sts=4 sr noet\n\n\n\n\nYou can just copy the .htaccess file from the Gishiki main rapository to your\napplication root, here I am reporting it:\n\n\nIfModule mod_rewrite.c\n\n    Options +FollowSymLinks\n    RewriteEngine On\n    RewriteCond %{REQUEST_FILENAME} !-f\n    RewriteCond %{REQUEST_FILENAME} !-d\n    RewriteRule ^ index.php [QSA,L]\n\n/IfModule\n\n\n\n\n\nYou can even be more aggressive here:\n\n\nIfModule mod_rewrite.c\n\n    RewriteEngine On\n    RewriteRule ^ index.php [QSA,L]\n\n/IfModule\n\n\n#allow requests from outside the domain\nHeader add Access-Control-Allow-Origin \n*\n\nHeader add Access-Control-Allow-Headers \norigin, x-requested-with, content-type\n\nHeader add Access-Control-Allow-Methods \nPUT, GET, POST, DELETE, OPTIONS\n\n\n\n\n\nThat shorted version will call the framework even if the client is asking for a\nresource that is a file inside you webroot!\n\n\nRemember that using .htaccess slows down your apache server,\nso if you have access to the configuration file of your production server you\n\nshould\n embed the provided \".htaccess\".", 
            "title": "Basic apache"
        }, 
        {
            "location": "/installation/basic_apache/#basic-apache-24", 
            "text": "If you are using a debian or ubuntu based distro you have to remember that you\nneed to enable mod_rewrite on apache:  sudo a2enmod rewrite\nsudo nano /etc/apache2/sites-available/000-default.conf\nsudo service apache2 restart  You must have AllowOverride set to \"All\" and not to \"None\" in the file being edited by nano.  When you are done with nano just ctrl+O, Enter, ctrl+X.  You can simply cut 'n' paste this configuration:  VirtualHost *:80 \n    #ServerName www.example.com\n\n    ServerAdmin webmaster@localhost\n    DocumentRoot /var/www/html\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n        # globally allow .htaccess\n     Directory  /var/www/html \n        AllowOverride All\n     /Directory  /VirtualHost \n\n# vim: syntax=apache ts=4 sw=4 sts=4 sr noet  You can just copy the .htaccess file from the Gishiki main rapository to your\napplication root, here I am reporting it:  IfModule mod_rewrite.c \n    Options +FollowSymLinks\n    RewriteEngine On\n    RewriteCond %{REQUEST_FILENAME} !-f\n    RewriteCond %{REQUEST_FILENAME} !-d\n    RewriteRule ^ index.php [QSA,L] /IfModule   You can even be more aggressive here:  IfModule mod_rewrite.c \n    RewriteEngine On\n    RewriteRule ^ index.php [QSA,L] /IfModule \n\n#allow requests from outside the domain\nHeader add Access-Control-Allow-Origin  * \nHeader add Access-Control-Allow-Headers  origin, x-requested-with, content-type \nHeader add Access-Control-Allow-Methods  PUT, GET, POST, DELETE, OPTIONS   That shorted version will call the framework even if the client is asking for a\nresource that is a file inside you webroot!  Remember that using .htaccess slows down your apache server,\nso if you have access to the configuration file of your production server you should  embed the provided \".htaccess\".", 
            "title": "Basic Apache 2.4"
        }, 
        {
            "location": "/installation/basic_lighttpd/", 
            "text": "Basic lighttpd\n\n\nIf you are planning to use lighttpd as webserver for your application you\n\nMUST\n be provided with instructions:\n\n\nurl.rewrite-if-not-file = (\n(.*)\n =\n \n/index.php/$0\n)\n\n\n\n\nThere you are! You just need to paste that code into the configuration file of lighttpd!\n\n\nThis requires lighttpd \n= 1.4.24.", 
            "title": "Basic lighttpd"
        }, 
        {
            "location": "/installation/basic_lighttpd/#basic-lighttpd", 
            "text": "If you are planning to use lighttpd as webserver for your application you MUST  be provided with instructions:  url.rewrite-if-not-file = ( (.*)  =   /index.php/$0 )  There you are! You just need to paste that code into the configuration file of lighttpd!  This requires lighttpd  = 1.4.24.", 
            "title": "Basic lighttpd"
        }, 
        {
            "location": "/installation/basic_iis/", 
            "text": "Basic IIS\n\n\nYou shouldn't be using IIS, really, just... \ndon't\n.\n\n\nIf \nREALLY HAVE TO\n use IIS and you have no other choice make sure you have a\nfile called Web.config alongside with an index.php file in the same\npublic-accessible directory.\n\n\nThe Web.config file should contain this code:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nconfiguration\n\n    \nsystem.webServer\n\n        \nrewrite\n\n            \nrules\n\n                \nrule name=\nslim\n patternSyntax=\nWildcard\n\n                    \nmatch url=\n*\n /\n\n                    \nconditions\n\n                        \nadd input=\n{REQUEST_FILENAME}\n matchType=\nIsFile\n negate=\ntrue\n /\n\n                        \nadd input=\n{REQUEST_FILENAME}\n matchType=\nIsDirectory\n negate=\ntrue\n /\n\n                    \n/conditions\n\n                    \naction type=\nRewrite\n url=\nindex.php\n /\n\n                \n/rule\n\n            \n/rules\n\n        \n/rewrite\n\n    \n/system.webServer\n\n\n/configuration\n\n\n\n\n\nHowever, you \nREALLY\n should keep distances from IIS (at least when using it with PHP)!", 
            "title": "Basic IIS"
        }, 
        {
            "location": "/installation/basic_iis/#basic-iis", 
            "text": "You shouldn't be using IIS, really, just...  don't .  If  REALLY HAVE TO  use IIS and you have no other choice make sure you have a\nfile called Web.config alongside with an index.php file in the same\npublic-accessible directory.  The Web.config file should contain this code:  ?xml version= 1.0  encoding= UTF-8 ?  configuration \n     system.webServer \n         rewrite \n             rules \n                 rule name= slim  patternSyntax= Wildcard \n                     match url= *  / \n                     conditions \n                         add input= {REQUEST_FILENAME}  matchType= IsFile  negate= true  / \n                         add input= {REQUEST_FILENAME}  matchType= IsDirectory  negate= true  / \n                     /conditions \n                     action type= Rewrite  url= index.php  / \n                 /rule \n             /rules \n         /rewrite \n     /system.webServer  /configuration   However, you  REALLY  should keep distances from IIS (at least when using it with PHP)!", 
            "title": "Basic IIS"
        }, 
        {
            "location": "/installation/composer/", 
            "text": "Composer\n\n\nAs promised Gishiki is not meant to replace your favourite tools: you can still use all of them!\n\n\nDoctrine? Propel? Zend framework components? Symfony components? No problem!\n\n\nYou have to install them and you do that using composer! If you don't have composer run:\n\n\nphp -r \nreadfile('https://getcomposer.org/installer');\n \n composer-setup.php\nphp -r \nif (hash('SHA384', file_get_contents('composer-setup.php')) === '7228c001f88bee97506740ef0888240bd8a760b046ee16db8f4095c0d8d525f2367663f22a46b48d072c816e7fe19959') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;\n\nphp composer-setup.php\nphp -r \nunlink('composer-setup.php');\n\n\n\n\n\nRemember that composer is essential to run Gishiki: composer is what loads the\nentire framework and manages the framework version!\n\n\nBootstrapping an application\n\n\nYou like digging immediatly into development? No problem!\n\n\nI have setup a \nsmall application\n example you can fork to have something you can\ninstantly develop on!\n\n\nFresh start\n\n\nYou like reading documentation or you have great experience with Gishiki? Another time... No problem!\n\n\nYou can use composer to start up your new project!\n\n\nphp composer.phar create-project neroreflex/gishiki path\n\n\n\n\nnice and easy! Good work!", 
            "title": "Composer"
        }, 
        {
            "location": "/installation/composer/#composer", 
            "text": "As promised Gishiki is not meant to replace your favourite tools: you can still use all of them!  Doctrine? Propel? Zend framework components? Symfony components? No problem!  You have to install them and you do that using composer! If you don't have composer run:  php -r  readfile('https://getcomposer.org/installer');    composer-setup.php\nphp -r  if (hash('SHA384', file_get_contents('composer-setup.php')) === '7228c001f88bee97506740ef0888240bd8a760b046ee16db8f4095c0d8d525f2367663f22a46b48d072c816e7fe19959') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL; \nphp composer-setup.php\nphp -r  unlink('composer-setup.php');   Remember that composer is essential to run Gishiki: composer is what loads the\nentire framework and manages the framework version!", 
            "title": "Composer"
        }, 
        {
            "location": "/installation/composer/#bootstrapping-an-application", 
            "text": "You like digging immediatly into development? No problem!  I have setup a  small application  example you can fork to have something you can\ninstantly develop on!", 
            "title": "Bootstrapping an application"
        }, 
        {
            "location": "/installation/composer/#fresh-start", 
            "text": "You like reading documentation or you have great experience with Gishiki? Another time... No problem!  You can use composer to start up your new project!  php composer.phar create-project neroreflex/gishiki path  nice and easy! Good work!", 
            "title": "Fresh start"
        }, 
        {
            "location": "/installation/paas/", 
            "text": "PaaS\n\n\nPaaS\n stands for: \nP\nlatform \na\ns \na\n \nS\nervice.\n\n\nA PaaS is a service that give life to your application, which is hosted in a\ncloud (often sandboxed) environment, giving you additional protection to your\napplication and abstracting away from you the problem of scaling large-scale\nserver intensive applications.\n\n\nA PaaS provider ofter adds to its service a set of utilities that simplify your\nlife, especially with automatic content delivery and/or application update:\nfor example Heroku automatically Sync your application with its GitHub repository\nand automatically deploy your application on each push if it passes the\nautomatic integration testing set!\n\n\nA small list of supported PaaS may be:\n\n\n\n\nHeroku\n\n\nOpenShift\n\n\nGoogle AppEngine\n\n\nMicrosoft Azure\n\n\n\n\nBut there are many, many more of them: everything that can run PHP 5.4 will work!\n\n\nGetting Started\n\n\nGishiki is tested costantly with Heroku because Heroku is fantastic\nand empowers your application with a lot of simple tools without forcing you to\nmaintain a server or a container!\n\n\nSetting up a perfectly working Heroku/OpenShift application is super-easy:\n\n\n\n\nFork \nthis\n repository on GitHub\n\n\nRegister \n Login to your PaaS provider website\n\n\nCreate a new application using your PaaS provider website\n\n\nSetup auto-deploy using your PaaS provider website\n\n\nClone your new GitHub application to your local drive\n\n\n\n\nEdit locally your application, commit and when a \ngit push\n is performed to GitHub your\nHeroku/openShift application is automatically updated! Have fun \n3.\n\n\nDatabase\n\n\nYou are free to host your database everywhere, but Heroku, OpenShift and many\nothers PaaS are providing database support as simple add-ons to your application,\nand Gishiki is able to take advantage of those add-ons!\n\n\nFor example you can pick the \"Heroku Postgres\" add-on to have for free a PostgreSQL\ndatabase binded with your application!", 
            "title": "PaaS"
        }, 
        {
            "location": "/installation/paas/#paas", 
            "text": "PaaS  stands for:  P latform  a s  a   S ervice.  A PaaS is a service that give life to your application, which is hosted in a\ncloud (often sandboxed) environment, giving you additional protection to your\napplication and abstracting away from you the problem of scaling large-scale\nserver intensive applications.  A PaaS provider ofter adds to its service a set of utilities that simplify your\nlife, especially with automatic content delivery and/or application update:\nfor example Heroku automatically Sync your application with its GitHub repository\nand automatically deploy your application on each push if it passes the\nautomatic integration testing set!  A small list of supported PaaS may be:   Heroku  OpenShift  Google AppEngine  Microsoft Azure   But there are many, many more of them: everything that can run PHP 5.4 will work!", 
            "title": "PaaS"
        }, 
        {
            "location": "/installation/paas/#getting-started", 
            "text": "Gishiki is tested costantly with Heroku because Heroku is fantastic\nand empowers your application with a lot of simple tools without forcing you to\nmaintain a server or a container!  Setting up a perfectly working Heroku/OpenShift application is super-easy:   Fork  this  repository on GitHub  Register   Login to your PaaS provider website  Create a new application using your PaaS provider website  Setup auto-deploy using your PaaS provider website  Clone your new GitHub application to your local drive   Edit locally your application, commit and when a  git push  is performed to GitHub your\nHeroku/openShift application is automatically updated! Have fun  3.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/installation/paas/#database", 
            "text": "You are free to host your database everywhere, but Heroku, OpenShift and many\nothers PaaS are providing database support as simple add-ons to your application,\nand Gishiki is able to take advantage of those add-ons!  For example you can pick the \"Heroku Postgres\" add-on to have for free a PostgreSQL\ndatabase binded with your application!", 
            "title": "Database"
        }, 
        {
            "location": "/apidoc/", 
            "text": "API Documentation\n\n\nThe API Documentation is automatically build from PHPDoc comments into the Gishiki source code.\n\n\nThe API Documentation is the most advanced and up-to-date documentation you can find,\nbut you will need to know how to use Gishiki before understanding that documentation.\n\n\nThe API Documentation is perfect to have an overview of what you can do using Gishiki and \nhow Gishiki is organized internally.\n\n\nAccessing the docs\n\n\nYou can access the API Documentation from \nhere\n.\n\n\nIf you are totally unable to understand what is described there just don't worry about\nit, you can do amazing things even without reading that thing!", 
            "title": "API"
        }, 
        {
            "location": "/apidoc/#api-documentation", 
            "text": "The API Documentation is automatically build from PHPDoc comments into the Gishiki source code.  The API Documentation is the most advanced and up-to-date documentation you can find,\nbut you will need to know how to use Gishiki before understanding that documentation.  The API Documentation is perfect to have an overview of what you can do using Gishiki and \nhow Gishiki is organized internally.", 
            "title": "API Documentation"
        }, 
        {
            "location": "/apidoc/#accessing-the-docs", 
            "text": "You can access the API Documentation from  here .  If you are totally unable to understand what is described there just don't worry about\nit, you can do amazing things even without reading that thing!", 
            "title": "Accessing the docs"
        }, 
        {
            "location": "/usage/configuration/", 
            "text": "Configuration\n\n\nGishiki is a bit tricky to configure, but don't worry: you just need to copy the\nstructure of the JSON file below and change what you don't like:\n\n\nthe real configuration file and application descriptor is stored inside the application\ndirectory and is called settings.json\n\n\nIt has a fixed (minumum) structure:\n\n\n{\n    \ngeneral\n: {\n        \ndevelopment\n: true,\n        \nautolog\n: null\n    },\n\n    \nsecurity\n: {\n        \nserverPassword\n: \n{{@MASTER_KEY}}\n,\n        \nserverKey\n: \n{{@SERVER_KEY}}\n\n    },\n\n    \nconnections\n: [\n        {\n            \nname\n: \ndefault\n,\n            \nquery\n: \nmongodb://user:pass@localhost:27017/dbname\n\n        }\n    ],\n\n    \npipeline\n: {\n        \nconnection\n: \ndefault\n,\n        \ncollection\n: \ndbname.tablename\n\n    }\n}\n\n\n\n\nAs you might have thought those {{@VAR_NAMES}} are replaced with constants defined\nin your environment AND/OR Heroku \"Config Variables\"!\n\n\nThis is a \nGREAT\n feature that keeps \nSECRET\n your database connection descriptor and\nyour master server key while allowing application portability among illimitate environments!\n\n\nAutomatic Logger\n\n\nThe automatic logger is the logger automatically used to store log entries generated by\nan exception.\n\n\nTo understand how to connect a logger it is important to read the \nLogging\n chapter of this manual.\n\n\nUsing null (as in the above example) will discard each log entry.\n\n\nServer Key\n\n\nThe server key is a serialized RSA private key as OpenSSL can deserialize it:\na PEM formatted private key or PEM encoded certificate/private key.\n\n\nThe serialized key \nCANNOT\n be password encrypted.\n\n\nThe server key can be embedded into the JSON, but it may not be the best solution:\nyou should either create an environment variable holding the serialized key calling it MASTER_KEY\nand recycle the example code, or giving a file path to the serialized key, for example:\n\"file:///absolute/path/to/file.pem\" or \"file://relative/path/to/file.pem\".\n\n\nThe file path can also be the value of the environment variable, but that is not suggested.\n\n\nThe private key can be of any length and power of two, however 4096 or bigger\nis suggested.\n\n\nopenssl genrsa -out relative/path/to/file.pem 4096\n\n\n\n\nThat is the OpenSSL CLI command that may be used to generate a valid RSA private key.\n\n\nServer Password\n\n\nThe server password is what will be used as the default server symmetric key.\n\n\nUnlike the server private key, the server password has a fixed length and it must\nbe 64 characters long!", 
            "title": "Configuration"
        }, 
        {
            "location": "/usage/configuration/#configuration", 
            "text": "Gishiki is a bit tricky to configure, but don't worry: you just need to copy the\nstructure of the JSON file below and change what you don't like:  the real configuration file and application descriptor is stored inside the application\ndirectory and is called settings.json  It has a fixed (minumum) structure:  {\n     general : {\n         development : true,\n         autolog : null\n    },\n\n     security : {\n         serverPassword :  {{@MASTER_KEY}} ,\n         serverKey :  {{@SERVER_KEY}} \n    },\n\n     connections : [\n        {\n             name :  default ,\n             query :  mongodb://user:pass@localhost:27017/dbname \n        }\n    ],\n\n     pipeline : {\n         connection :  default ,\n         collection :  dbname.tablename \n    }\n}  As you might have thought those {{@VAR_NAMES}} are replaced with constants defined\nin your environment AND/OR Heroku \"Config Variables\"!  This is a  GREAT  feature that keeps  SECRET  your database connection descriptor and\nyour master server key while allowing application portability among illimitate environments!", 
            "title": "Configuration"
        }, 
        {
            "location": "/usage/configuration/#automatic-logger", 
            "text": "The automatic logger is the logger automatically used to store log entries generated by\nan exception.  To understand how to connect a logger it is important to read the  Logging  chapter of this manual.  Using null (as in the above example) will discard each log entry.", 
            "title": "Automatic Logger"
        }, 
        {
            "location": "/usage/configuration/#server-key", 
            "text": "The server key is a serialized RSA private key as OpenSSL can deserialize it:\na PEM formatted private key or PEM encoded certificate/private key.  The serialized key  CANNOT  be password encrypted.  The server key can be embedded into the JSON, but it may not be the best solution:\nyou should either create an environment variable holding the serialized key calling it MASTER_KEY\nand recycle the example code, or giving a file path to the serialized key, for example:\n\"file:///absolute/path/to/file.pem\" or \"file://relative/path/to/file.pem\".  The file path can also be the value of the environment variable, but that is not suggested.  The private key can be of any length and power of two, however 4096 or bigger\nis suggested.  openssl genrsa -out relative/path/to/file.pem 4096  That is the OpenSSL CLI command that may be used to generate a valid RSA private key.", 
            "title": "Server Key"
        }, 
        {
            "location": "/usage/configuration/#server-password", 
            "text": "The server password is what will be used as the default server symmetric key.  Unlike the server private key, the server password has a fixed length and it must\nbe 64 characters long!", 
            "title": "Server Password"
        }, 
        {
            "location": "/usage/routing/", 
            "text": "Routing\n\n\nWhen a request arrives the framework must fulfill it.\n\n\nThe framework automatically maps a request to a resource located at \"https://site.com/Home\" into \"/Home\" (GET request).\n\n\nThe /Home string is the URI of the requested resource, the GET request is the HTTP method used to query that resource...\nthe question is.... \n\n\nHow do I route that request to what I want to serve? The answer is: using the router!\n\n\nThe router is that fantastic component empowering your user-friendly URLs!\n\n\nDifferent methods\n\n\nAs for HTTP standards a client can perform a resource request using these verbs:\n\n\n\n\nGET identified as Route::GET\n\n\nPOST  identified as Route::POST\n\n\nDELETE identified as Route::DELETE\n\n\nPUT identified as Route::PUT\n\n\nHEAD identified as Route::HEAD\n\n\nPATCH identified as Route::PATCH\n\n\nOPTIONS identified as Route::OPTIONS\n\n\n\n\nWhen you set a routing rule (either static or dynamic) you have to select the \nverb that you want to be served in that route.\n\n\nThis is particulary handy when creating a RESTful service.\n\n\nStatic Rules\n\n\nLet's see how to create a custom route:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for \nhttps://site.com/\n (the homepage)\n\n    //let's just forget about MVC pattern this time :)\n    echo \nHello, World!\n;\n});\n\n\n\n\nTo try this rule out you have to open rules.php and paste the provided code into \nit and direct your browser to: https://site.com (the trailing / is automatically added).\n\n\nDynamic Rules\n\n\nThis route is really simple: just an URI check... but you are creating a dynamic application, \nand URIs cannot be static URIs every time, in fact sooner or later you will need to capture a parameter passed \nas a parameter with the URL.\n\n\nLet's just consider this simple example:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get(\n/Hello/{name_surname}\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for \nhttps://site.com/User/urName+urSurname\n\n\n    //nice to meet you!\n    $response-\nwrite(\nHello, \n.$arguments-\n{\nname_surname\n}.\n!\n);\n});\n\nRoute::get(\n/Home/{name}\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for \nhttps://site.com/Home/some_name\n\n\n    //nice to meet you!\n    $response-\nwrite(\nHello, \n.$arguments-\nname.\n!\n);\n});\n\n\n\n\nYou already know what you are going to do, right? :D\n\n\nhttps://site.com/Home/your_name and you will see \"Hello, your_name!\" nothing complex here, right?\n\n\nCustom Dynamic Rules\n\n\nYou might want to catch something more specific than just \"everything but '/'\",\nsay for example an integer or an email address:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get(\n/Hello/{user_email:email}\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for \nhttps://site.com/Hello/yourEmail%40address.com\n\n\n    //send that mail!\n    if (!mail($arguments-\nuser_email , \nGishiki RESTful test\n , \nWelcome to my RESTful test service \n3\n)) {\n        $default_logger = new Logger();\n        $default_logger-\nwarning(\nAn e-mail is missing :(\n);\n    }\n});\n\n\n\n\nThat's great isn't it? Actually what you can catch is:\n\n\n\n\n'default' a generic string\n\n\n'email' an email address\n\n\n'integer' an integer number\n\n\n\n\nAll request methods\n\n\nSometimes you may need to register a route that responds to all HTTP verbs, you \nare allowed to do that by using 'any':\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //do something general with your homepage!\n});\n\n\n\n\nthe action is taken if that URI is hit, regardless of the method the client used \nto perform the request.\n\n\nTwo or more request methods\n\n\nAn interesting feature of the router is how you create a route for two or more\nrequest methods:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::match([Route::GET, Route::POST], \n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //you want your homepage to be reached only with get and post\n});\n\n\n\n\nthe action is taken if that URI is hit only when using get or post request method. \n\n\nError catching\n\n\nYou know, things doesn't always go as you want: it is necessary to think about \nunexpected circumstances. You do it by setting an error callback, \nwhich is nothing more than a bit special routing rule:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for an unrouted URI\n\n    //error message!\n    $response-\nwrite(\nSorry man, you are asking for something I can't give you :(\n);\n});\n\n\n\n\nAs you can see an error routing rule (or error callback) is exactly any other URI\nand follows the same exact rules, however for known errors the HTTP status code is\nautomatically changed (for example if a Route::NOT_FOUND URI is catched 404 Not Found\nis added automatically to the response).\n\n\nYou cannot change this behaviour, but you can change the status code:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for an unrouted URI\n    $response-\nwithStatus(500);\n\n    //error message!\n    $response-\nwrite(\nSorry man, you are asking for something I can't give you :(\n);\n});\n\n\n\n\nA bit stange to send to the client a 500 Internal Server Error for a missing\nresource, but nothing stops you from doing that.\n\n\nLimitation\n\n\nYou cannot route URIs that start with /api/ or /service/ because they are reserved for web services (explained in a different chapter).\n\n\nYou cannot match something that has a slash '/' character using a dynamic placeholder: {name} cannot capture something like \"mario/rossi\".\n\n\nConclusions\n\n\nThe router is the fastest and easiest component within Gishiki, \nbecause it is the first component that is used and the only one you \nREALLY HAVE TO\n use.\n\n\nThis means that you are now good to go... Everything you \nMUST\n know in order to use Gishiki ends here.\n\n\nEverything else is a plus you may need to accelerate the development of your projects,\nalthough you should really learn how to deal with the \nRequest\n and the \nResponse\n objects passed to you.", 
            "title": "Router"
        }, 
        {
            "location": "/usage/routing/#routing", 
            "text": "When a request arrives the framework must fulfill it.  The framework automatically maps a request to a resource located at \"https://site.com/Home\" into \"/Home\" (GET request).  The /Home string is the URI of the requested resource, the GET request is the HTTP method used to query that resource...\nthe question is....   How do I route that request to what I want to serve? The answer is: using the router!  The router is that fantastic component empowering your user-friendly URLs!", 
            "title": "Routing"
        }, 
        {
            "location": "/usage/routing/#different-methods", 
            "text": "As for HTTP standards a client can perform a resource request using these verbs:   GET identified as Route::GET  POST  identified as Route::POST  DELETE identified as Route::DELETE  PUT identified as Route::PUT  HEAD identified as Route::HEAD  PATCH identified as Route::PATCH  OPTIONS identified as Route::OPTIONS   When you set a routing rule (either static or dynamic) you have to select the \nverb that you want to be served in that route.  This is particulary handy when creating a RESTful service.", 
            "title": "Different methods"
        }, 
        {
            "location": "/usage/routing/#static-rules", 
            "text": "Let's see how to create a custom route:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for  https://site.com/  (the homepage)\n\n    //let's just forget about MVC pattern this time :)\n    echo  Hello, World! ;\n});  To try this rule out you have to open rules.php and paste the provided code into \nit and direct your browser to: https://site.com (the trailing / is automatically added).", 
            "title": "Static Rules"
        }, 
        {
            "location": "/usage/routing/#dynamic-rules", 
            "text": "This route is really simple: just an URI check... but you are creating a dynamic application, \nand URIs cannot be static URIs every time, in fact sooner or later you will need to capture a parameter passed \nas a parameter with the URL.  Let's just consider this simple example:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get( /Hello/{name_surname} ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for  https://site.com/User/urName+urSurname \n\n    //nice to meet you!\n    $response- write( Hello,  .$arguments- { name_surname }. ! );\n});\n\nRoute::get( /Home/{name} ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for  https://site.com/Home/some_name \n\n    //nice to meet you!\n    $response- write( Hello,  .$arguments- name. ! );\n});  You already know what you are going to do, right? :D  https://site.com/Home/your_name and you will see \"Hello, your_name!\" nothing complex here, right?", 
            "title": "Dynamic Rules"
        }, 
        {
            "location": "/usage/routing/#custom-dynamic-rules", 
            "text": "You might want to catch something more specific than just \"everything but '/'\",\nsay for example an integer or an email address:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get( /Hello/{user_email:email} ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for  https://site.com/Hello/yourEmail%40address.com \n\n    //send that mail!\n    if (!mail($arguments- user_email ,  Gishiki RESTful test  ,  Welcome to my RESTful test service  3 )) {\n        $default_logger = new Logger();\n        $default_logger- warning( An e-mail is missing :( );\n    }\n});  That's great isn't it? Actually what you can catch is:   'default' a generic string  'email' an email address  'integer' an integer number", 
            "title": "Custom Dynamic Rules"
        }, 
        {
            "location": "/usage/routing/#all-request-methods", 
            "text": "Sometimes you may need to register a route that responds to all HTTP verbs, you \nare allowed to do that by using 'any':  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //do something general with your homepage!\n});  the action is taken if that URI is hit, regardless of the method the client used \nto perform the request.", 
            "title": "All request methods"
        }, 
        {
            "location": "/usage/routing/#two-or-more-request-methods", 
            "text": "An interesting feature of the router is how you create a route for two or more\nrequest methods:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::match([Route::GET, Route::POST],  / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //you want your homepage to be reached only with get and post\n});  the action is taken if that URI is hit only when using get or post request method.", 
            "title": "Two or more request methods"
        }, 
        {
            "location": "/usage/routing/#error-catching", 
            "text": "You know, things doesn't always go as you want: it is necessary to think about \nunexpected circumstances. You do it by setting an error callback, \nwhich is nothing more than a bit special routing rule:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for an unrouted URI\n\n    //error message!\n    $response- write( Sorry man, you are asking for something I can't give you :( );\n});  As you can see an error routing rule (or error callback) is exactly any other URI\nand follows the same exact rules, however for known errors the HTTP status code is\nautomatically changed (for example if a Route::NOT_FOUND URI is catched 404 Not Found\nis added automatically to the response).  You cannot change this behaviour, but you can change the status code:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for an unrouted URI\n    $response- withStatus(500);\n\n    //error message!\n    $response- write( Sorry man, you are asking for something I can't give you :( );\n});  A bit stange to send to the client a 500 Internal Server Error for a missing\nresource, but nothing stops you from doing that.", 
            "title": "Error catching"
        }, 
        {
            "location": "/usage/routing/#limitation", 
            "text": "You cannot route URIs that start with /api/ or /service/ because they are reserved for web services (explained in a different chapter).  You cannot match something that has a slash '/' character using a dynamic placeholder: {name} cannot capture something like \"mario/rossi\".", 
            "title": "Limitation"
        }, 
        {
            "location": "/usage/routing/#conclusions", 
            "text": "The router is the fastest and easiest component within Gishiki, \nbecause it is the first component that is used and the only one you  REALLY HAVE TO  use.  This means that you are now good to go... Everything you  MUST  know in order to use Gishiki ends here.  Everything else is a plus you may need to accelerate the development of your projects,\nalthough you should really learn how to deal with the  Request  and the  Response  objects passed to you.", 
            "title": "Conclusions"
        }, 
        {
            "location": "/usage/request/", 
            "text": "Request\n\n\nThe \nGishiki\\HttpKernel\\Request\n class is used to fully represent an HTTP request.\n\n\nThe Request class is PSR-7 conformant and follows that specification sheet.\n\n\nRequest Method\n\n\nWhen an HTTP request is sent to the server the client has to specify the type of the\nrequest, that request type is called 'method'.\n\n\nUsually you work with following methods:\n\n\n\n\nGET\n\n\nPOST\n\n\nPUT\n\n\nDELETE\n\n\nHEAD\n\n\nPATCH\n\n\nOPTIONS\n\n\n\n\nbut your application can also support your own methods!\n\n\nYou can inspect the HTTP request\u2019s method with the Request object method\nappropriately named getMethod()\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/method_test\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $method = $request-\ngetMethod();\n\n    //this is what will be executed when the client asks for an unrouted URI\n    $response-\nwithStatus(200);\n\n    //error message!\n    $response-\nwrite(\nYou have used the \n.$method.\n method to fetch this page!\n);\n});\n\n\n\n\nHowever you can override the standard HTTP method including in the header an\nX-Http-Method-Override property, for example:\n\n\nPOST /path HTTP/1.1\nHost: example.com\nContent-type: application/json\nX-Http-Method-Override: PUT\n\n\n\n\nAnd the code before will return the string \"PUT\", and not the string \"POST\".\n\n\nIf you want to retrive the real HTTP method used (non-overridden) you can do it\nusing another function which is called getOriginalMethod():\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/method_test\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $method = $request-\ngetMethod();\n    $origin_method = $request-\ngetOriginalMethod();\n\n    //this is what will be executed when the client asks for an unrouted URI\n    $response-\nwithStatus(200);\n\n    //error message!\n    $response-\nwrite(\nYou have used the \n.$method.\n method to fetch this page!\\n\n);\n\n    if ($method != $origin_method) \n        $response-\nwrite(\nHowever the request used the \n.$origin_method.\n method to fetch this page!\\n\n);\n});\n\n\n\n\nIf you try overriding the HTTP method you will see the you will be found cheating :D\n\n\nRequest URI\n\n\nEvery HTTP request has a URI that identifies the requested application resource.\nThe HTTP request URI is composite of several parts:\n\n\n\n\nScheme (e.g. http or https)\n\n\nHost (e.g. example.com)\n\n\nPort (e.g. 80 or 443)\n\n\nPath (e.g. /users/1)\n\n\nQuery string (e.g. sort=created\ndir=asc)\n\n\n\n\nYou can fetch the Request object\u2019s URI using its getUri() method:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/method_test\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //get the URI of the current request\n    $uri = $request-\ngetUri();\n\n    //do something with this URI\n});\n\n\n\n\nOperation allowed on an URI are:\n\n\n\n\ngetScheme()\n\n\ngetAuthority()\n\n\ngetUserInfo()\n\n\ngetHost()\n\n\ngetPort()\n\n\ngetPath()\n\n\ngetBasePath()\n\n\ngetQuery()\n\n\ngetFragment()\n\n\ngetBaseUrl()\n\n\ngetQueryParams()\n\n\n\n\nwhere getQueryParams() returns an associative array, getQuery() returns the complete\nquery string and getBaseUrl() the complete URL of the request.\n\n\nRequest Headers\n\n\nHeaders are metadata that describe the HTTP request but are not visible in the\nrequest\u2019s body.\n\n\nEach header can contain more values: this is why the velue of a single header is\nrepresented as a non-associative array.\n\n\nYou can have the complete list of headers, in form of an associative array by\ncalling the getHeaders() function the interested request.\n\n\nA simple example can be:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    foreach ($request-\ngetHeaders() as $name =\n $values) {\n        $response-\nwrite(\nname: \n. $name . \n =\n values:\n . implode(\n, \n, $values));\n    }\n});\n\n\n\n\nseparing each value of the request with a comma is equal is equal to calling the\ngetHeaderLine('header_name') function on the interested request.\n\n\nThe previous example can be rewritten as:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    foreach (array_keys($request-\ngetHeaders()) as $name) {\n        $response-\nwrite(\nname: \n. $name . \n =\n values:\n . $request-\ngetHeaderLine($name);\n    }\n});\n\n\n\n\nYou can test the existance of a given header calling the hasHeader('header_name')\nfunction.\n\n\nIf the result is true you can safely call the getHeader('header_name') function\nthat will return the non-associative array representing the header values.\n\n\nRequest Body\n\n\nAn HTTP request may have a body following its header.\n\n\nThat body is useful when creating a RESTful service, because it may contains lots\nof information about the requested action.\n\n\nWithin Gishiki you can access the body of the interested request as a stream\nPSR-7 compilant. You can obtain that stream calling the getBody() function.\n\n\nLet's look into an example:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //get the body stream\n    $body = $request-\ngetBody();\n\n    //rewind the stream (aka reset the cursor at the beginning of the stream)\n    $body-\nrewind();\n\n    //read the entire request body\n    $request = \n;\n    while (!$body-\neof()) {\n        $request .= read(1);\n    }\n\n    //have fun with your request body!\n});\n\n\n\n\nI know what you are thinking... You could parse that request body to obtain\nsomething like an array or a class that you can use within your application....\n\n\nWell, if that's the case you may appreciate the fact that Gishiki does this\nin your place!\n\n\nTo trigger the request body automatic parsing you can use the getParsedBody()\nfunction that triggers the better parser for the given 'Content-type' header!", 
            "title": "Request"
        }, 
        {
            "location": "/usage/request/#request", 
            "text": "The  Gishiki\\HttpKernel\\Request  class is used to fully represent an HTTP request.  The Request class is PSR-7 conformant and follows that specification sheet.", 
            "title": "Request"
        }, 
        {
            "location": "/usage/request/#request-method", 
            "text": "When an HTTP request is sent to the server the client has to specify the type of the\nrequest, that request type is called 'method'.  Usually you work with following methods:   GET  POST  PUT  DELETE  HEAD  PATCH  OPTIONS   but your application can also support your own methods!  You can inspect the HTTP request\u2019s method with the Request object method\nappropriately named getMethod()  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /method_test ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $method = $request- getMethod();\n\n    //this is what will be executed when the client asks for an unrouted URI\n    $response- withStatus(200);\n\n    //error message!\n    $response- write( You have used the  .$method.  method to fetch this page! );\n});  However you can override the standard HTTP method including in the header an\nX-Http-Method-Override property, for example:  POST /path HTTP/1.1\nHost: example.com\nContent-type: application/json\nX-Http-Method-Override: PUT  And the code before will return the string \"PUT\", and not the string \"POST\".  If you want to retrive the real HTTP method used (non-overridden) you can do it\nusing another function which is called getOriginalMethod():  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /method_test ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $method = $request- getMethod();\n    $origin_method = $request- getOriginalMethod();\n\n    //this is what will be executed when the client asks for an unrouted URI\n    $response- withStatus(200);\n\n    //error message!\n    $response- write( You have used the  .$method.  method to fetch this page!\\n );\n\n    if ($method != $origin_method) \n        $response- write( However the request used the  .$origin_method.  method to fetch this page!\\n );\n});  If you try overriding the HTTP method you will see the you will be found cheating :D", 
            "title": "Request Method"
        }, 
        {
            "location": "/usage/request/#request-uri", 
            "text": "Every HTTP request has a URI that identifies the requested application resource.\nThe HTTP request URI is composite of several parts:   Scheme (e.g. http or https)  Host (e.g. example.com)  Port (e.g. 80 or 443)  Path (e.g. /users/1)  Query string (e.g. sort=created dir=asc)   You can fetch the Request object\u2019s URI using its getUri() method:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /method_test ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //get the URI of the current request\n    $uri = $request- getUri();\n\n    //do something with this URI\n});  Operation allowed on an URI are:   getScheme()  getAuthority()  getUserInfo()  getHost()  getPort()  getPath()  getBasePath()  getQuery()  getFragment()  getBaseUrl()  getQueryParams()   where getQueryParams() returns an associative array, getQuery() returns the complete\nquery string and getBaseUrl() the complete URL of the request.", 
            "title": "Request URI"
        }, 
        {
            "location": "/usage/request/#request-headers", 
            "text": "Headers are metadata that describe the HTTP request but are not visible in the\nrequest\u2019s body.  Each header can contain more values: this is why the velue of a single header is\nrepresented as a non-associative array.  You can have the complete list of headers, in form of an associative array by\ncalling the getHeaders() function the interested request.  A simple example can be:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    foreach ($request- getHeaders() as $name =  $values) {\n        $response- write( name:  . $name .   =  values:  . implode( ,  , $values));\n    }\n});  separing each value of the request with a comma is equal is equal to calling the\ngetHeaderLine('header_name') function on the interested request.  The previous example can be rewritten as:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    foreach (array_keys($request- getHeaders()) as $name) {\n        $response- write( name:  . $name .   =  values:  . $request- getHeaderLine($name);\n    }\n});  You can test the existance of a given header calling the hasHeader('header_name')\nfunction.  If the result is true you can safely call the getHeader('header_name') function\nthat will return the non-associative array representing the header values.", 
            "title": "Request Headers"
        }, 
        {
            "location": "/usage/request/#request-body", 
            "text": "An HTTP request may have a body following its header.  That body is useful when creating a RESTful service, because it may contains lots\nof information about the requested action.  Within Gishiki you can access the body of the interested request as a stream\nPSR-7 compilant. You can obtain that stream calling the getBody() function.  Let's look into an example:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //get the body stream\n    $body = $request- getBody();\n\n    //rewind the stream (aka reset the cursor at the beginning of the stream)\n    $body- rewind();\n\n    //read the entire request body\n    $request =  ;\n    while (!$body- eof()) {\n        $request .= read(1);\n    }\n\n    //have fun with your request body!\n});  I know what you are thinking... You could parse that request body to obtain\nsomething like an array or a class that you can use within your application....  Well, if that's the case you may appreciate the fact that Gishiki does this\nin your place!  To trigger the request body automatic parsing you can use the getParsedBody()\nfunction that triggers the better parser for the given 'Content-type' header!", 
            "title": "Request Body"
        }, 
        {
            "location": "/usage/response/", 
            "text": "Response\n\n\nThe \nGishiki\\HttpKernel\\Response\n class is used to fully represent an HTTP response.\n\n\nThe Response class is PSR-7 conformant and follows that specification sheet.\n\n\nEach \nRequest\n triggers the generation of a response.\n\n\nThat response is automatically sent back to the client at the end of the\napplication lifetime.\n\n\nThe main target of an application is \nediting\n that response before the departure\nof that response.\n\n\nAn HTTP response is made of two parts:\n\n\n\n\nResponse \nheader\n \n\n\nResponse \nbody\n\n\n\n\nThose parts and steps to generate them are described later on this document.\n\n\nResponse Header\n\n\nEvery HTTP response \nMUST\n contains an header.\n\n\nAn HTTP header have a bare minimum structure that comprises the HTTP revision,\nthe status code and the message associated to the status code.\n\n\nSince each status code have its own predefined status phrase (like 404 not found,\n500 internal server error, 200 OK and so on) when the status code is changed the\nstatus phrase is automatically changed by the framework.\n\n\nThat can be done calling the \nwithStatus\n function:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //the response code - phrase will be 404 - Not Found\n    $response-\nwithStatus(404);\n});\n\n\n\n\nYou can manually change the status phrase, but you are discouraged from doing such\nthing with standard status code!\n\n\nWhat you can do is using it to send a strong signal to a bad client:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/complex\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //numberOfRequests is the number of requests that a client has sent today\n    if ($numberOfRequests \n 5) {\n        //perform the complex operation (may stress the system)\n        action();\n    } else {\n        //stop flooding my servers!\n        $response-\nwithStatus(666, 'FUCK YOU!');\n    }\n});\n\n\n\n\nSorry for the bad language, that was only intended to help me to give you a (real :D)\nexample of usage.\n\n\nResponse Header Details\n\n\nEach response can contains a lot of details about itselfs like the length of the\ncontent or the type of the content.\n\n\nEach 'response detail' is a collection of values binded to a key which is the name\nof the property.\n\n\nIn order to edit the value of a property you have to use the \nwithHeader\n function:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/complex\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $request-\nwithHeader('Cache-Control', 'no-store, no-cache, must-revalidate');\n});\n\n\n\n\nIf you are unsure on how to use this feature you should read more about http response \nheader\n.\n\n\nResponse Body\n\n\nThe body of the response is the main part of the response: the \ncontent\n of the\nresponse.\n\n\nFor example if the response is an html content the response body is what the\nuser calls \nthe webpage\n.\n\n\nTo directly modify the response body you can use the \nwrite\n function:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $content = \nEOT\n\nhtml\n\n    \nhead\n\n        \ntitle\nMy webpage\n/title\n\n    \n/head\n\n    \nbody\n\n        \nh1\nMy webpage\n/h1\n\n        \np\nHello, this is my personal webpage!\n/p\n\n    \n/body\n\n\n/html\n\nEOT;\n\n    //write the response\n    $response-\nwithHeader('Content-Type', 'text/html');\n    $response-\nwrite($content);\n});\n\n\n\n\nThis is a simple example to Gishiki used to generate an html response,\nhowever since Gishiki is built to be used as the foundation of RESTful services\nthe response body shoild be a JSON, XML, YAML etc... content.\n\n\nTo generate a response body from a serializable data collection Gishiki provides\na function that automate this process: this function is called \nsetSerializedBody\n\nand does more than just converting a collection to a fixed format:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/factorial/{int:integer}\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $x = $arguments-\nint;\n    $factorial = fact($x);\n\n    $data = new SerializableCollection([\n        'timestamp' =\n time(),\n        'result'    =\n $factorial,\n    ]);\n\n    $response-\nsetSerializedBody($data);\n});\n\n\n\n\nThe given collection may be serialized to a JSON content, XML content or YAML content.\nYou may decide the content type by setting the header 'Content-Type' \nBUT THAT IS A WASTE OF TIME\n:\nGishiki \nAUTOMAGICALLY\n uses the content type listening for client preferences.\n\n\nThis means that a client is not enforced to be able to deserialize a specific\ncontent type, but can choose the preferred content-type including it on the\nhttp request header using the 'Accept' property!\n\n\nFollowing accept values are used to request a specific data serialization format:\n\n\n\n\n'text/yaml'            -\n YAML\n\n\n'text/x-yaml'          -\n YAML\n\n\n'application/yaml'     -\n YAML\n\n\n'application/x-yaml'   -\n XML\n\n\n'application/xml'      -\n XML\n\n\n'text/xml'             -\n XML\n\n\n'application/json'     -\n JSON\n\n\n\n\nAnything else triggers the default serialization format, which is JSON!", 
            "title": "Response"
        }, 
        {
            "location": "/usage/response/#response", 
            "text": "The  Gishiki\\HttpKernel\\Response  class is used to fully represent an HTTP response.  The Response class is PSR-7 conformant and follows that specification sheet.  Each  Request  triggers the generation of a response.  That response is automatically sent back to the client at the end of the\napplication lifetime.  The main target of an application is  editing  that response before the departure\nof that response.  An HTTP response is made of two parts:   Response  header    Response  body   Those parts and steps to generate them are described later on this document.", 
            "title": "Response"
        }, 
        {
            "location": "/usage/response/#response-header", 
            "text": "Every HTTP response  MUST  contains an header.  An HTTP header have a bare minimum structure that comprises the HTTP revision,\nthe status code and the message associated to the status code.  Since each status code have its own predefined status phrase (like 404 not found,\n500 internal server error, 200 OK and so on) when the status code is changed the\nstatus phrase is automatically changed by the framework.  That can be done calling the  withStatus  function:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //the response code - phrase will be 404 - Not Found\n    $response- withStatus(404);\n});  You can manually change the status phrase, but you are discouraged from doing such\nthing with standard status code!  What you can do is using it to send a strong signal to a bad client:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /complex ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //numberOfRequests is the number of requests that a client has sent today\n    if ($numberOfRequests   5) {\n        //perform the complex operation (may stress the system)\n        action();\n    } else {\n        //stop flooding my servers!\n        $response- withStatus(666, 'FUCK YOU!');\n    }\n});  Sorry for the bad language, that was only intended to help me to give you a (real :D)\nexample of usage.", 
            "title": "Response Header"
        }, 
        {
            "location": "/usage/response/#response-header-details", 
            "text": "Each response can contains a lot of details about itselfs like the length of the\ncontent or the type of the content.  Each 'response detail' is a collection of values binded to a key which is the name\nof the property.  In order to edit the value of a property you have to use the  withHeader  function:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /complex ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $request- withHeader('Cache-Control', 'no-store, no-cache, must-revalidate');\n});  If you are unsure on how to use this feature you should read more about http response  header .", 
            "title": "Response Header Details"
        }, 
        {
            "location": "/usage/response/#response-body", 
            "text": "The body of the response is the main part of the response: the  content  of the\nresponse.  For example if the response is an html content the response body is what the\nuser calls  the webpage .  To directly modify the response body you can use the  write  function:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $content =  EOT html \n     head \n         title My webpage /title \n     /head \n     body \n         h1 My webpage /h1 \n         p Hello, this is my personal webpage! /p \n     /body  /html \nEOT;\n\n    //write the response\n    $response- withHeader('Content-Type', 'text/html');\n    $response- write($content);\n});  This is a simple example to Gishiki used to generate an html response,\nhowever since Gishiki is built to be used as the foundation of RESTful services\nthe response body shoild be a JSON, XML, YAML etc... content.  To generate a response body from a serializable data collection Gishiki provides\na function that automate this process: this function is called  setSerializedBody \nand does more than just converting a collection to a fixed format:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /factorial/{int:integer} ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $x = $arguments- int;\n    $factorial = fact($x);\n\n    $data = new SerializableCollection([\n        'timestamp' =  time(),\n        'result'    =  $factorial,\n    ]);\n\n    $response- setSerializedBody($data);\n});  The given collection may be serialized to a JSON content, XML content or YAML content.\nYou may decide the content type by setting the header 'Content-Type'  BUT THAT IS A WASTE OF TIME :\nGishiki  AUTOMAGICALLY  uses the content type listening for client preferences.  This means that a client is not enforced to be able to deserialize a specific\ncontent type, but can choose the preferred content-type including it on the\nhttp request header using the 'Accept' property!  Following accept values are used to request a specific data serialization format:   'text/yaml'            -  YAML  'text/x-yaml'          -  YAML  'application/yaml'     -  YAML  'application/x-yaml'   -  XML  'application/xml'      -  XML  'text/xml'             -  XML  'application/json'     -  JSON   Anything else triggers the default serialization format, which is JSON!", 
            "title": "Response Body"
        }, 
        {
            "location": "/usage/logging/", 
            "text": "Logging\n\n\nGishiki comes with a simple and small logging library that may use different logging\ntechnologies like the UNIX logging daemon (and its emulation on Windows).\n\n\nThe logger included in Gishiki is PSR-3 compilant and is super-simple to setup and use!\n\n\nGetting a logger\n\n\nWithin Gishiki each time you want to store a log entry a logger object is required.\n\n\nThe logger object is derived from the Gishiki\\Logging\\Logger class.\n\n\nWhen creating a new instance of the logger class you may and may not pass\n(to the class constructor) a string that identify the method used to store log entries.\n\n\nIf you don't pass an URL to the newly created Logger instance than the default one\nwill be used (see \nconfiguration\n for an example of configuration\nwith \"autolog\" set to null).\n\n\nConnection\n\n\nThe connection string is an URL with the following structure:\n\n\nadapter://resource\n\n\n\n\nWhen the adapter is the adapter used to access the resource and the resource is specific\nwith one adapter.\n\n\nAt the moment supported adapters are:\n\n\n\n\nfile\n\n\ngelf\n\n\nstream\n\n\nsyslog\n\n\nnull\n\n\n\n\nA valid example can be:\n\n\n$logger = new Gishiki\\Logger\\Logging(\nfile://logs.txt\n);\n\n\n\n\nYou need to read the correct sub-character of the page to understand how to identify the\nresource to be used.\n\n\nFile\n\n\nIf a file is used to register log entries the resource is given as a path to the file.\n\n\nThe file MUST be accessible with write permissions to php.\n\n\nThe file path can either be given as a relative path or an absolute file.\n\n\nfile:///var/logs/myApp.log\n\n\n\n\nthis will store the log in the /var/logs/myApp.log file.\n\n\nSyslog\n\n\nIf you want the Unix syslogd service to be responsible for log management than the\nconfiguration string must be something like:\n\n\nsyslog://myAppName\n\n\n\n\nWhere myAppName is the name of your application.\n\n\nThis is particularly useful if you want to be able to entirely customize the \nlog management process or avoid file-write permission problems.\n\n\nStream\n\n\nSometimes, due to the system configuration, you may want to save your logs on stdout,\nstderr or a memory stream.\n\n\nstream://\nstream_name\n\n\n\n\n\nThe \nstream name\n can be one of the following:\n\n\n\n\nstdout\n\n\nstderr\n\n\nstdmem\n\n\n\n\nGraylog\n\n\nIf you have an active graylog server you can send log entries to that server by\nenstabilishing a connection using a query like:\n\n\ngelf://\nprotocol\n:\nhostname\n:\nport\n\n\n\n\n\nWhere \nprotocol\n can be either \nUDP\n or \nTCP\n.\n\n\nWriting a log entry\n\n\nTo send a log entry you must call the \nlog\n function.\n\n\nThe first argument is the level of severity, it can be one of the following:\n\n\n\n\n\\Psr\\Log\\LogLevel::EMERGENCY -\n 'emergency'\n\n\n\\Psr\\Log\\LogLevel::ALERT -\n 'alert'\n\n\n\\Psr\\Log\\LogLevel::CRITICAL -\n 'critical'\n\n\n\\Psr\\Log\\LogLevel::ERROR -\n 'error'\n\n\n\\Psr\\Log\\LogLevel::WARNING -\n 'warning'\n\n\n\\Psr\\Log\\LogLevel::NOTICE -\n 'notice'\n\n\n\\Psr\\Log\\LogLevel::INFO -\n 'info'\n\n\n\\Psr\\Log\\LogLevel::DEBUG -\n 'debug'\n\n\n\n\nyou can use either the string or the contant provided by the psr package (suggested).\n\n\nThe second argument is the message, and the third argument is a collection of\ndetails as a simple PHP array:\n\n\n$logger = new Logger(\ngelf://\nprotocol\n:\nhostname\n:\nport\n);\n$logger-\nlog(\\Psr\\Log\\LogLevel::EMERGENCY, \nEnvironmental temperature too high\n, [\n        'temperature' =\n 56.7,\n    ]);\n\n\n\n\nWith stream and file adapters the collection of values are a sobstitution mask\nfor the message:\n\n\n$logger = new Logger(\nstream://stdout\n);\n$logger-\nlog(\\Psr\\Log\\LogLevel::EMERGENCY, \nEnvironmental temperature too high: {{temperature}} \u00b0C\n, [\n        'temperature' =\n 56.7,\n    ]);\n\n\n\n\nThat code will print out the string \"Environmental temperature too high: 56.7 \u00b0C\"\nas a result.\n\n\nSpecialized Writers\n\n\nIt is possible (permitted by the PSR-3 standard) to call a specialized function\nthat identify itselfs the severity of the log entry, those functions are called\nlike the severity to be used:\n\n\n$logger = new Logger(\nstream://stdout\n);\n$logger-\nemergency(\nEnvironmental temperature too high: {{temperature}} \u00b0C\n, [\n        'temperature' =\n 56.7,\n    ]);\n\n\n\n\nThe complete list of those functions is:\n\n\n\n\nemergency\n\n\nalert\n\n\ncritical\n\n\nerror\n\n\nwarning\n\n\nnotice\n\n\ninfo\n\n\ndebug", 
            "title": "Logger"
        }, 
        {
            "location": "/usage/logging/#logging", 
            "text": "Gishiki comes with a simple and small logging library that may use different logging\ntechnologies like the UNIX logging daemon (and its emulation on Windows).  The logger included in Gishiki is PSR-3 compilant and is super-simple to setup and use!", 
            "title": "Logging"
        }, 
        {
            "location": "/usage/logging/#getting-a-logger", 
            "text": "Within Gishiki each time you want to store a log entry a logger object is required.  The logger object is derived from the Gishiki\\Logging\\Logger class.  When creating a new instance of the logger class you may and may not pass\n(to the class constructor) a string that identify the method used to store log entries.  If you don't pass an URL to the newly created Logger instance than the default one\nwill be used (see  configuration  for an example of configuration\nwith \"autolog\" set to null).", 
            "title": "Getting a logger"
        }, 
        {
            "location": "/usage/logging/#connection", 
            "text": "The connection string is an URL with the following structure:  adapter://resource  When the adapter is the adapter used to access the resource and the resource is specific\nwith one adapter.  At the moment supported adapters are:   file  gelf  stream  syslog  null   A valid example can be:  $logger = new Gishiki\\Logger\\Logging( file://logs.txt );  You need to read the correct sub-character of the page to understand how to identify the\nresource to be used.", 
            "title": "Connection"
        }, 
        {
            "location": "/usage/logging/#file", 
            "text": "If a file is used to register log entries the resource is given as a path to the file.  The file MUST be accessible with write permissions to php.  The file path can either be given as a relative path or an absolute file.  file:///var/logs/myApp.log  this will store the log in the /var/logs/myApp.log file.", 
            "title": "File"
        }, 
        {
            "location": "/usage/logging/#syslog", 
            "text": "If you want the Unix syslogd service to be responsible for log management than the\nconfiguration string must be something like:  syslog://myAppName  Where myAppName is the name of your application.  This is particularly useful if you want to be able to entirely customize the \nlog management process or avoid file-write permission problems.", 
            "title": "Syslog"
        }, 
        {
            "location": "/usage/logging/#stream", 
            "text": "Sometimes, due to the system configuration, you may want to save your logs on stdout,\nstderr or a memory stream.  stream:// stream_name   The  stream name  can be one of the following:   stdout  stderr  stdmem", 
            "title": "Stream"
        }, 
        {
            "location": "/usage/logging/#graylog", 
            "text": "If you have an active graylog server you can send log entries to that server by\nenstabilishing a connection using a query like:  gelf:// protocol : hostname : port   Where  protocol  can be either  UDP  or  TCP .", 
            "title": "Graylog"
        }, 
        {
            "location": "/usage/logging/#writing-a-log-entry", 
            "text": "To send a log entry you must call the  log  function.  The first argument is the level of severity, it can be one of the following:   \\Psr\\Log\\LogLevel::EMERGENCY -  'emergency'  \\Psr\\Log\\LogLevel::ALERT -  'alert'  \\Psr\\Log\\LogLevel::CRITICAL -  'critical'  \\Psr\\Log\\LogLevel::ERROR -  'error'  \\Psr\\Log\\LogLevel::WARNING -  'warning'  \\Psr\\Log\\LogLevel::NOTICE -  'notice'  \\Psr\\Log\\LogLevel::INFO -  'info'  \\Psr\\Log\\LogLevel::DEBUG -  'debug'   you can use either the string or the contant provided by the psr package (suggested).  The second argument is the message, and the third argument is a collection of\ndetails as a simple PHP array:  $logger = new Logger( gelf:// protocol : hostname : port );\n$logger- log(\\Psr\\Log\\LogLevel::EMERGENCY,  Environmental temperature too high , [\n        'temperature' =  56.7,\n    ]);  With stream and file adapters the collection of values are a sobstitution mask\nfor the message:  $logger = new Logger( stream://stdout );\n$logger- log(\\Psr\\Log\\LogLevel::EMERGENCY,  Environmental temperature too high: {{temperature}} \u00b0C , [\n        'temperature' =  56.7,\n    ]);  That code will print out the string \"Environmental temperature too high: 56.7 \u00b0C\"\nas a result.", 
            "title": "Writing a log entry"
        }, 
        {
            "location": "/usage/logging/#specialized-writers", 
            "text": "It is possible (permitted by the PSR-3 standard) to call a specialized function\nthat identify itselfs the severity of the log entry, those functions are called\nlike the severity to be used:  $logger = new Logger( stream://stdout );\n$logger- emergency( Environmental temperature too high: {{temperature}} \u00b0C , [\n        'temperature' =  56.7,\n    ]);  The complete list of those functions is:   emergency  alert  critical  error  warning  notice  info  debug", 
            "title": "Specialized Writers"
        }, 
        {
            "location": "/usage/pipeline/", 
            "text": "Pipeline\n\n\nA pipeline is a collection of steps to be executed in a precise order: it is\ndefined as an instance of the \nGishiki\\Pipeline\\Pipeline\n class.\n\n\nWith a pipeline you \nMAY\n or \nMAY NOT\n have the full control of the pipeline\nexecution.\n\n\nPipelines are great when you have to execute long operations outside the context\nof the operation request, but are also great to control the result of those operation\nin a different time from theirs execution.\n\n\nConfigure the pipeline\n\n\nIn order for the pipeline to work a \ndatabase\n connection must be active\non the current \nconfiguration\n and a table with the chosen name must exists.\n\n\nThe table used to backup the pipeline support \nMUST\n be structured like this:\n\n\n\n\n_id [integer / table ID]\n\n\nuniqID [string - max. 26 character (NOT NULL)]\n\n\nstatus [integer (NOT NULL)]\n\n\ntype [integer (NOT NULL)]\n\n\npriority [integer (NOT NULL)]\n\n\ncreationTime [integer (NOT NULL)]\n\n\ncompletionReports [string / collection]\n\n\npipeline [string (NOT NULL)]\n\n\nabortMessage [string]\n\n\nserializableCollection [string / collection]\n\n\n\n\nField types are to be defined only where necessary: on mongodb it is impossible,\njust let the framework to take care!\n\n\nPipeline Definition\n\n\nTo execute a pipeline you have to define it.\n\n\nA pipeline \nMUST\n have a name and a collection of zero or more steps.\n\n\nObviously a pipeline with 0 steps is totally useless!\n\n\nA pipeline with the same name of an another pipeline \nCANNOT\n exists: at the moment\nof creation an exception will be thrown and the new pipeline will cease to exists!\n\n\nDefining a pipeline is done like this:\n\n\nuse Gishiki\\Pipeline\\Pipeline;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\n//create the pipeline\n$pipeline = new Pipeline(\nEmailUser\n);\n\n//add a step to the pipeline\n$pipeline-\nbindStage('send', function (SerializableCollection \n$collection) {\n    //send the email (long task)\n    return mail($collection-\ndest, $collection-\nobj, $collection-\nmsg);\n});\n\n\n\n\nNow it is clear that $collection is an argument that will be passed when the\npipeline will be executed.\n\n\nA pipeline should be defined in a file called as the pipeline inside the folder\ncalled 'pipelines', which is inside the 'application' folder.\n\n\nPipeline Runtime\n\n\nIn order for the pipeline execution to take place a runtime \nMUST\n be created.\n\n\nA pipeline runtime is an instance of the \nGishiki\\Pipeline\\PipelineRuntime\n class.\n\n\nA runtime is created from a specific pipeline, have a type and a priority.\n\n\nRuntime Type\n\n\nThe type of the runtime identifies the timing of the execution, the type \nMUST\n be\none of the following possible types:\n\n\n\n\nGishiki\\Pipeline\\RuntimeType::ASYNCHRONOUS \n\n\nGishiki\\Pipeline\\RuntimeType::SYNCHRONOUS\n\n\n\n\nA synchronous runtime is a runtime that has a known execution timing: it is certain\n\nWHEN\n the pipeline is executed, because the execution is triggered on demand.\n\n\nAn asynchronous runtime is executed with an unknown timing: you can only be sure that\nsooner or later it \nWILL FOR SURE\n be executed.\n\n\nRuntime Priority\n\n\nThe priority of a pipeline changes the execution timing of an ASYNCHRONOUS runtime:\nit has no effects on a SYNCHRONOUS runtime.\n\n\nThe higher the runtime priority the lower the time to wait before the execution\nof the ASYNCHRONOUS runtime!\n\n\nPipeline Execution\n\n\nTo create a runtime (described above in the \"Pipeline Runtime\" section) an instance\nof the Pipeline to be executed is needed.\n\n\nYou can retrieve it knowing its name like this:\n\n\nuse Gishiki\\Pipeline\\Pipeline;\nuse Gishiki\\Pipeline\\PipelineCollector;\nuse Gishiki\\Pipeline\\PipelineRuntime;\nuse Gishiki\\Pipeline\\PipelineRuntime;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\n//retrieve the pipeline\n$pipeline = PipelineCollector::getPipelineByName(\nEmailUser\n);\n\n//create the runtime with given params\n$pipelineExecutor = new PipelineRuntime($pipeline, RuntimeType::SYNCHRONOUS, RuntimePriority::LOWEST, [\n    'dest'  =\n '',\n    'obj'   =\n '',\n    'msg'   =\n ''\n]);\n\n//execute ALL STAGES of the pipeline\n$pipelineExecutor();\n\n\n\n\nIf (like in the previous example) you created a pipeline that needs input parameters\nin order to work you can add those parameters as the fourth parameter of the PipelineRuntime constructor.\n\n\nNote:\n the runtime is SYNCHRONOUS, so the priority is ignored, but you can change\nthe runtime type while executing the pipeline!\n\n\nUsing the runtime object as a function will cause the runtime to execute the first\nx stages of the pipeline, if x is not given, as in the example then \nALL\n the pipeline\nwill be executed!\n\n\nChanging Type\n\n\nThe type of a reuntime can be changed while executing that pipeline by calling\n\nPipelineSupport::ChangeType\n where the first argument is the new type of the pipeline:\n\n\nuse Gishiki\\Pipeline\\Pipeline;\nuse Gishiki\\Pipeline\\PipelineSupport;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\n//create the pipeline\n$pipeline = new Pipeline(\nEmailUser\n);\n\n//add a step to the pipeline\n$pipeline-\nbindStage('send', function (SerializableCollection \n$collection) {\n    //change the type\n    PipelineSupport::ChangeType(RuntimeType::ASYNCHRONOUS);\n\n    //send the email (long task)\n    return mail($collection-\ndest, $collection-\nobj, $collection-\nmsg);\n});\n\n\n\n\nWARNING:\n changing the pipeline from asynchronous to synchronous the execution\nwill be stopped after completion of the stage!\n\n\nAborting Execution\n\n\nThere are situations where the runtime, to avoid serious problems, \nMUST\n be\naborted.\n\n\nIn future you may want to read the reason that forced the abort of the runtime.\n\n\nTo abort the runtime you can call \nPipelineSupport::Abort\n passing as argument\na string explaining what is happening:\n\n\nuse Gishiki\\Pipeline\\Pipeline;\nuse Gishiki\\Pipeline\\PipelineSupport;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\n//create the pipeline\n$pipeline = new Pipeline(\nEmailUser\n);\n\n//add a step to the pipeline\n$pipeline-\nbindStage('send', function (SerializableCollection \n$collection) {\n    //change the type\n    PipelineSupport::ChangeType(RuntimeType::ASYNCHRONOUS);\n\n    //send the email (long task)\n    if (!mail($collection-\ndest, $collection-\nobj, $collection-\nmsg))\n        PipelineSupport::Abort(\nFailed to send the mail.\n);\n});\n\n\n\n\nCronjob\n\n\nYou have seen how to execute synchronous runtimes, but what about asynchronous?\n\n\nWell, Gishiki is providing a cronjob that executes a number of\nasynchronous runtimes when called.\n\n\nThat cronjob is invoked by an HTTP request to /cronjob address.\n\n\nIn an production environment (see \nconficuration\n chapter) /cronjob\ncan be called by everyone, since it \nNEVER EXPOSES\n important output!\n\n\nYou can configure the number of runtimes to complete by including (in the request\nbody) a json that once evaluated will produce a SerializableCollection that has\na key named 'runtimes' that has as value the number of runtimes to be executed. \n\n\nWorking example:\n\n\nGET /cronjob HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n    \nruntimes\n: 8\n}\n\n\n\n\nThis will execute 8 asynchronous runtimes until the end is reached.", 
            "title": "Pipeline"
        }, 
        {
            "location": "/usage/pipeline/#pipeline", 
            "text": "A pipeline is a collection of steps to be executed in a precise order: it is\ndefined as an instance of the  Gishiki\\Pipeline\\Pipeline  class.  With a pipeline you  MAY  or  MAY NOT  have the full control of the pipeline\nexecution.  Pipelines are great when you have to execute long operations outside the context\nof the operation request, but are also great to control the result of those operation\nin a different time from theirs execution.", 
            "title": "Pipeline"
        }, 
        {
            "location": "/usage/pipeline/#configure-the-pipeline", 
            "text": "In order for the pipeline to work a  database  connection must be active\non the current  configuration  and a table with the chosen name must exists.  The table used to backup the pipeline support  MUST  be structured like this:   _id [integer / table ID]  uniqID [string - max. 26 character (NOT NULL)]  status [integer (NOT NULL)]  type [integer (NOT NULL)]  priority [integer (NOT NULL)]  creationTime [integer (NOT NULL)]  completionReports [string / collection]  pipeline [string (NOT NULL)]  abortMessage [string]  serializableCollection [string / collection]   Field types are to be defined only where necessary: on mongodb it is impossible,\njust let the framework to take care!", 
            "title": "Configure the pipeline"
        }, 
        {
            "location": "/usage/pipeline/#pipeline-definition", 
            "text": "To execute a pipeline you have to define it.  A pipeline  MUST  have a name and a collection of zero or more steps.  Obviously a pipeline with 0 steps is totally useless!  A pipeline with the same name of an another pipeline  CANNOT  exists: at the moment\nof creation an exception will be thrown and the new pipeline will cease to exists!  Defining a pipeline is done like this:  use Gishiki\\Pipeline\\Pipeline;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\n//create the pipeline\n$pipeline = new Pipeline( EmailUser );\n\n//add a step to the pipeline\n$pipeline- bindStage('send', function (SerializableCollection  $collection) {\n    //send the email (long task)\n    return mail($collection- dest, $collection- obj, $collection- msg);\n});  Now it is clear that $collection is an argument that will be passed when the\npipeline will be executed.  A pipeline should be defined in a file called as the pipeline inside the folder\ncalled 'pipelines', which is inside the 'application' folder.", 
            "title": "Pipeline Definition"
        }, 
        {
            "location": "/usage/pipeline/#pipeline-runtime", 
            "text": "In order for the pipeline execution to take place a runtime  MUST  be created.  A pipeline runtime is an instance of the  Gishiki\\Pipeline\\PipelineRuntime  class.  A runtime is created from a specific pipeline, have a type and a priority.", 
            "title": "Pipeline Runtime"
        }, 
        {
            "location": "/usage/pipeline/#runtime-type", 
            "text": "The type of the runtime identifies the timing of the execution, the type  MUST  be\none of the following possible types:   Gishiki\\Pipeline\\RuntimeType::ASYNCHRONOUS   Gishiki\\Pipeline\\RuntimeType::SYNCHRONOUS   A synchronous runtime is a runtime that has a known execution timing: it is certain WHEN  the pipeline is executed, because the execution is triggered on demand.  An asynchronous runtime is executed with an unknown timing: you can only be sure that\nsooner or later it  WILL FOR SURE  be executed.", 
            "title": "Runtime Type"
        }, 
        {
            "location": "/usage/pipeline/#runtime-priority", 
            "text": "The priority of a pipeline changes the execution timing of an ASYNCHRONOUS runtime:\nit has no effects on a SYNCHRONOUS runtime.  The higher the runtime priority the lower the time to wait before the execution\nof the ASYNCHRONOUS runtime!", 
            "title": "Runtime Priority"
        }, 
        {
            "location": "/usage/pipeline/#pipeline-execution", 
            "text": "To create a runtime (described above in the \"Pipeline Runtime\" section) an instance\nof the Pipeline to be executed is needed.  You can retrieve it knowing its name like this:  use Gishiki\\Pipeline\\Pipeline;\nuse Gishiki\\Pipeline\\PipelineCollector;\nuse Gishiki\\Pipeline\\PipelineRuntime;\nuse Gishiki\\Pipeline\\PipelineRuntime;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\n//retrieve the pipeline\n$pipeline = PipelineCollector::getPipelineByName( EmailUser );\n\n//create the runtime with given params\n$pipelineExecutor = new PipelineRuntime($pipeline, RuntimeType::SYNCHRONOUS, RuntimePriority::LOWEST, [\n    'dest'  =  '',\n    'obj'   =  '',\n    'msg'   =  ''\n]);\n\n//execute ALL STAGES of the pipeline\n$pipelineExecutor();  If (like in the previous example) you created a pipeline that needs input parameters\nin order to work you can add those parameters as the fourth parameter of the PipelineRuntime constructor.  Note:  the runtime is SYNCHRONOUS, so the priority is ignored, but you can change\nthe runtime type while executing the pipeline!  Using the runtime object as a function will cause the runtime to execute the first\nx stages of the pipeline, if x is not given, as in the example then  ALL  the pipeline\nwill be executed!", 
            "title": "Pipeline Execution"
        }, 
        {
            "location": "/usage/pipeline/#changing-type", 
            "text": "The type of a reuntime can be changed while executing that pipeline by calling PipelineSupport::ChangeType  where the first argument is the new type of the pipeline:  use Gishiki\\Pipeline\\Pipeline;\nuse Gishiki\\Pipeline\\PipelineSupport;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\n//create the pipeline\n$pipeline = new Pipeline( EmailUser );\n\n//add a step to the pipeline\n$pipeline- bindStage('send', function (SerializableCollection  $collection) {\n    //change the type\n    PipelineSupport::ChangeType(RuntimeType::ASYNCHRONOUS);\n\n    //send the email (long task)\n    return mail($collection- dest, $collection- obj, $collection- msg);\n});  WARNING:  changing the pipeline from asynchronous to synchronous the execution\nwill be stopped after completion of the stage!", 
            "title": "Changing Type"
        }, 
        {
            "location": "/usage/pipeline/#aborting-execution", 
            "text": "There are situations where the runtime, to avoid serious problems,  MUST  be\naborted.  In future you may want to read the reason that forced the abort of the runtime.  To abort the runtime you can call  PipelineSupport::Abort  passing as argument\na string explaining what is happening:  use Gishiki\\Pipeline\\Pipeline;\nuse Gishiki\\Pipeline\\PipelineSupport;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\n//create the pipeline\n$pipeline = new Pipeline( EmailUser );\n\n//add a step to the pipeline\n$pipeline- bindStage('send', function (SerializableCollection  $collection) {\n    //change the type\n    PipelineSupport::ChangeType(RuntimeType::ASYNCHRONOUS);\n\n    //send the email (long task)\n    if (!mail($collection- dest, $collection- obj, $collection- msg))\n        PipelineSupport::Abort( Failed to send the mail. );\n});", 
            "title": "Aborting Execution"
        }, 
        {
            "location": "/usage/pipeline/#cronjob", 
            "text": "You have seen how to execute synchronous runtimes, but what about asynchronous?  Well, Gishiki is providing a cronjob that executes a number of\nasynchronous runtimes when called.  That cronjob is invoked by an HTTP request to /cronjob address.  In an production environment (see  conficuration  chapter) /cronjob\ncan be called by everyone, since it  NEVER EXPOSES  important output!  You can configure the number of runtimes to complete by including (in the request\nbody) a json that once evaluated will produce a SerializableCollection that has\na key named 'runtimes' that has as value the number of runtimes to be executed.   Working example:  GET /cronjob HTTP/1.1\nHost: example.com\nContent-Type: application/json\n\n{\n     runtimes : 8\n}  This will execute 8 asynchronous runtimes until the end is reached.", 
            "title": "Cronjob"
        }, 
        {
            "location": "/usage/database/", 
            "text": "Database\n\n\nGishiki is developed to reflect the MVC pattern: this means that the data lifecycle\nis a foundamental characteristic within the framework!\n\n\nData persistence, coherence and integrity is managed by the database manager.\n\n\nTo connect a database manager you have to edit the active \nconfiguration\n.\n\n\nThere isn't a limit to the number of database connection, but each one \nMUST\n\nhave a name, and there \nCANNOT\n be two connections with the same name.\n\n\nConnecting Database\n\n\nA database connection have the following form:\n\n\nadapter://adapter_manageable_conenction_query\n\n\n\n\nwhere the connection query is a string that the adapter can parse.\n\n\nMongoDB\n\n\nA MongoDB connection can be enstabilished by using the mongodb adapter bundled\nwith Gishiki.\n\n\nThe MongoDB adapter uses the mongodb php native extension: Composer calls it\n\next-mongodb\n: \n\n\nmongodb://username:password@host:port/dbname\n\n\n\n\nDifferences between databases\n\n\nEach database manager has different characteristics: Gishiki aims to preserve\nstrong points of each one, but miracles are not possibles: everything comes to\na price.\n\n\nFollowing are \nRULES\n you \nMUST\n follow when designing database tables.\n\n\n\n\nThe name must be the plural form of the name of object to store\n\n\nThe name must be written in underscore_case with no UPPER characters\n\n\nThe unique id field (when possible) must be called _id\n\n\n\n\nOperations on Databases\n\n\nTo understand how to interact with the database you have to read the \nCRUD\n\nchapter of this tutorial.", 
            "title": "Database"
        }, 
        {
            "location": "/usage/database/#database", 
            "text": "Gishiki is developed to reflect the MVC pattern: this means that the data lifecycle\nis a foundamental characteristic within the framework!  Data persistence, coherence and integrity is managed by the database manager.  To connect a database manager you have to edit the active  configuration .  There isn't a limit to the number of database connection, but each one  MUST \nhave a name, and there  CANNOT  be two connections with the same name.", 
            "title": "Database"
        }, 
        {
            "location": "/usage/database/#connecting-database", 
            "text": "A database connection have the following form:  adapter://adapter_manageable_conenction_query  where the connection query is a string that the adapter can parse.", 
            "title": "Connecting Database"
        }, 
        {
            "location": "/usage/database/#mongodb", 
            "text": "A MongoDB connection can be enstabilished by using the mongodb adapter bundled\nwith Gishiki.  The MongoDB adapter uses the mongodb php native extension: Composer calls it ext-mongodb :   mongodb://username:password@host:port/dbname", 
            "title": "MongoDB"
        }, 
        {
            "location": "/usage/database/#differences-between-databases", 
            "text": "Each database manager has different characteristics: Gishiki aims to preserve\nstrong points of each one, but miracles are not possibles: everything comes to\na price.  Following are  RULES  you  MUST  follow when designing database tables.   The name must be the plural form of the name of object to store  The name must be written in underscore_case with no UPPER characters  The unique id field (when possible) must be called _id", 
            "title": "Differences between databases"
        }, 
        {
            "location": "/usage/database/#operations-on-databases", 
            "text": "To understand how to interact with the database you have to read the  CRUD \nchapter of this tutorial.", 
            "title": "Operations on Databases"
        }, 
        {
            "location": "/usage/CRUD/", 
            "text": "CRUD\n\n\nThe acronym CRUD stands for Create, Read, Update and Delete: those are names of\noperations you will be allowed (directly or indirectly) to perform on databases\nyou are connected to.\n\n\nCreate\n\n\nThe creation of a new \ndocument\n starts from a \nCollectionInterface\n, such as\n\nSerializableCollection\n.\n\n\nThe function that has to be called is \nInsert\n that also requires the name of\nthe \ncollection\n to be affected:\n\n\nuse Gishiki\\Database\\DatabaseManager;\n\n$connection = DatabaseManager::Retrieve('connectionName');\n\n//since this is a mongodb database the table name is given as dbname.tbname\n$idOfNewDocument = $connection-\nInsert('dbname.tbname', new SerializableCollection([\n    'name'      =\n $name,\n    'surname'   =\n $surname,\n    'nickname'  =\n $nickname,\n    'password'  =\n $hash //it is NOT good to store plain passwords\n]));\n\n\n\n\nWhere the name of the connection is the same name in the application \nconfiguration\n.", 
            "title": "CRUD"
        }, 
        {
            "location": "/usage/CRUD/#crud", 
            "text": "The acronym CRUD stands for Create, Read, Update and Delete: those are names of\noperations you will be allowed (directly or indirectly) to perform on databases\nyou are connected to.", 
            "title": "CRUD"
        }, 
        {
            "location": "/usage/CRUD/#create", 
            "text": "The creation of a new  document  starts from a  CollectionInterface , such as SerializableCollection .  The function that has to be called is  Insert  that also requires the name of\nthe  collection  to be affected:  use Gishiki\\Database\\DatabaseManager;\n\n$connection = DatabaseManager::Retrieve('connectionName');\n\n//since this is a mongodb database the table name is given as dbname.tbname\n$idOfNewDocument = $connection- Insert('dbname.tbname', new SerializableCollection([\n    'name'      =  $name,\n    'surname'   =  $surname,\n    'nickname'  =  $nickname,\n    'password'  =  $hash //it is NOT good to store plain passwords\n]));  Where the name of the connection is the same name in the application  configuration .", 
            "title": "Create"
        }, 
        {
            "location": "/license/", 
            "text": "Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n\n\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n\n\n\n\n\nDefinitions.\n\n\n\"License\" shall mean the terms and conditions for use, reproduction,\n  and distribution as defined by Sections 1 through 9 of this document.\n\n\n\"Licensor\" shall mean the copyright owner or entity authorized by\n  the copyright owner that is granting the License.\n\n\n\"Legal Entity\" shall mean the union of the acting entity and all\n  other entities that control, are controlled by, or are under common\n  control with that entity. For the purposes of this definition,\n  \"control\" means (i) the power, direct or indirect, to cause the\n  direction or management of such entity, whether by contract or\n  otherwise, or (ii) ownership of fifty percent (50%) or more of the\n  outstanding shares, or (iii) beneficial ownership of such entity.\n\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity\n  exercising permissions granted by this License.\n\n\n\"Source\" form shall mean the preferred form for making modifications,\n  including but not limited to software source code, documentation\n  source, and configuration files.\n\n\n\"Object\" form shall mean any form resulting from mechanical\n  transformation or translation of a Source form, including but\n  not limited to compiled object code, generated documentation,\n  and conversions to other media types.\n\n\n\"Work\" shall mean the work of authorship, whether in Source or\n  Object form, made available under the License, as indicated by a\n  copyright notice that is included in or attached to the work\n  (an example is provided in the Appendix below).\n\n\n\"Derivative Works\" shall mean any work, whether in Source or Object\n  form, that is based on (or derived from) the Work and for which the\n  editorial revisions, annotations, elaborations, or other modifications\n  represent, as a whole, an original work of authorship. For the purposes\n  of this License, Derivative Works shall not include works that remain\n  separable from, or merely link (or bind by name) to the interfaces of,\n  the Work and Derivative Works thereof.\n\n\n\"Contribution\" shall mean any work of authorship, including\n  the original version of the Work and any modifications or additions\n  to that Work or Derivative Works thereof, that is intentionally\n  submitted to Licensor for inclusion in the Work by the copyright owner\n  or by an individual or Legal Entity authorized to submit on behalf of\n  the copyright owner. For the purposes of this definition, \"submitted\"\n  means any form of electronic, verbal, or written communication sent\n  to the Licensor or its representatives, including but not limited to\n  communication on electronic mailing lists, source code control systems,\n  and issue tracking systems that are managed by, or on behalf of, the\n  Licensor for the purpose of discussing and improving the Work, but\n  excluding communication that is conspicuously marked or otherwise\n  designated in writing by the copyright owner as \"Not a Contribution.\"\n\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity\n  on behalf of whom a Contribution has been received by Licensor and\n  subsequently incorporated within the Work.\n\n\n\n\n\n\nGrant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n\n\n\n\n\nGrant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n\n\n\n\n\nRedistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n\n(a) You must give any other recipients of the Work or\n      Derivative Works a copy of this License; and\n\n\n(b) You must cause any modified files to carry prominent notices\n      stating that You changed the files; and\n\n\n(c) You must retain, in the Source form of any Derivative Works\n      that You distribute, all copyright, patent, trademark, and\n      attribution notices from the Source form of the Work,\n      excluding those notices that do not pertain to any part of\n      the Derivative Works; and\n\n\n(d) If the Work includes a \"NOTICE\" text file as part of its\n      distribution, then any Derivative Works that You distribute must\n      include a readable copy of the attribution notices contained\n      within such NOTICE file, excluding those notices that do not\n      pertain to any part of the Derivative Works, in at least one\n      of the following places: within a NOTICE text file distributed\n      as part of the Derivative Works; within the Source form or\n      documentation, if provided along with the Derivative Works; or,\n      within a display generated by the Derivative Works, if and\n      wherever such third-party notices normally appear. The contents\n      of the NOTICE file are for informational purposes only and\n      do not modify the License. You may add Your own attribution\n      notices within Derivative Works that You distribute, alongside\n      or as an addendum to the NOTICE text from the Work, provided\n      that such additional attribution notices cannot be construed\n      as modifying the License.\n\n\nYou may add Your own copyright statement to Your modifications and\n  may provide additional or different license terms and conditions\n  for use, reproduction, or distribution of Your modifications, or\n  for any such Derivative Works as a whole, provided Your use,\n  reproduction, and distribution of the Work otherwise complies with\n  the conditions stated in this License.\n\n\n\n\n\n\nSubmission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n\n\n\n\n\nTrademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n\n\n\n\n\nDisclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n\n\n\n\n\nLimitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n\n\n\n\n\nAccepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n\n\n\n\n\nEND OF TERMS AND CONDITIONS", 
            "title": "License"
        }
    ]
}
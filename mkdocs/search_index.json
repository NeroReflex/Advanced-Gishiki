{
    "docs": [
        {
            "location": "/", 
            "text": "Gishiki\n\n\nGishiki\n: a modern and elegant MVC framework for PHP 7 and later versions.\n\n\nGishiki means 'ritual' in japanese, this name was chosen because this framework will help you to perform the\nritual of creation and deployment of web digital contents.\n\n\nDue to its design, this framework won't force you to use its features: you are completely free to use it as you wish,\neven if that breaks up MVC principles and/or uses a custom ORM.\n\n\nGishiki is so fast to deploy that you don't even need to configure it to get started!\n\n\nGive it a shot!\n\n\nYou want to try it, just to see if it really works, don't you?\n\n\nWell, to test it you need to \ninstall\n it!\n\n\nLicense\n\n\nGishiki is released under Apache-2.0 license terms, read the \nLICENSE\n to find out more!", 
            "title": "Home"
        }, 
        {
            "location": "/#gishiki", 
            "text": "Gishiki : a modern and elegant MVC framework for PHP 7 and later versions.  Gishiki means 'ritual' in japanese, this name was chosen because this framework will help you to perform the\nritual of creation and deployment of web digital contents.  Due to its design, this framework won't force you to use its features: you are completely free to use it as you wish,\neven if that breaks up MVC principles and/or uses a custom ORM.  Gishiki is so fast to deploy that you don't even need to configure it to get started!", 
            "title": "Gishiki"
        }, 
        {
            "location": "/#give-it-a-shot", 
            "text": "You want to try it, just to see if it really works, don't you?  Well, to test it you need to  install  it!", 
            "title": "Give it a shot!"
        }, 
        {
            "location": "/#license", 
            "text": "Gishiki is released under Apache-2.0 license terms, read the  LICENSE  to find out more!", 
            "title": "License"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nSetting up a project using Gishiki is really simple, even a child could be able to do it:\nhowever, in order to succeed you need to complete steps listed on the \nComposer\n page.\n\n\nFor the sake of simplicity, the application, while in development stage, can be\nrun using the \nphp built-in webserver\n.\n\n\nTo setup a production environment you should read the folling chapters.\n\n\nWindows\n\n\nIf you want to test Gishiki or develop your application on Windows, you can\nchoose between:\n\n Installing \nXAMPP\n and manually enable needed\nextensions on php.ini (suggested for ancient PC that cannot run a Virtual Machine)\n\n Installing \nVirtualBox\n and \nVagrant\n\nand use the provided Vagrantfile to setup a fully-working linux environment!\n\n\nMac OS X\n\n\nIf you are willing to \ndevelop\n your application on a Mac system you can either use\n\nXAMPP\n or the PHP built-in webserver.\n\n\nLinux\n\n\nEvery production server runs on a linux or a container inside linux, this is why\nevery instruction you'll find are written for linux and tested with Ubuntu 16.04.\n\n\nIf you are a newcomer I suggest you to follow the \nPHP 7.0 \n nginx\n\ntutorial I have written for you.\n\n\nVirtual Machine\n\n\nIf you don't want to pollute your desktop environment you can use a virtualization\nprogram, like \nVirtualBox\n, to install \nUbuntu Server\n and\nfollow the tutorial on that virtual machine!\n\n\nLet's go!\n\n\nIf you want something that works in a few seconds than the \nPaaS\n page\nis the right manual page!", 
            "title": "Environment"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "Setting up a project using Gishiki is really simple, even a child could be able to do it:\nhowever, in order to succeed you need to complete steps listed on the  Composer  page.  For the sake of simplicity, the application, while in development stage, can be\nrun using the  php built-in webserver .  To setup a production environment you should read the folling chapters.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#windows", 
            "text": "If you want to test Gishiki or develop your application on Windows, you can\nchoose between:  Installing  XAMPP  and manually enable needed\nextensions on php.ini (suggested for ancient PC that cannot run a Virtual Machine)  Installing  VirtualBox  and  Vagrant \nand use the provided Vagrantfile to setup a fully-working linux environment!", 
            "title": "Windows"
        }, 
        {
            "location": "/installation/#mac-os-x", 
            "text": "If you are willing to  develop  your application on a Mac system you can either use XAMPP  or the PHP built-in webserver.", 
            "title": "Mac OS X"
        }, 
        {
            "location": "/installation/#linux", 
            "text": "Every production server runs on a linux or a container inside linux, this is why\nevery instruction you'll find are written for linux and tested with Ubuntu 16.04.  If you are a newcomer I suggest you to follow the  PHP 7.0   nginx \ntutorial I have written for you.", 
            "title": "Linux"
        }, 
        {
            "location": "/installation/#virtual-machine", 
            "text": "If you don't want to pollute your desktop environment you can use a virtualization\nprogram, like  VirtualBox , to install  Ubuntu Server  and\nfollow the tutorial on that virtual machine!", 
            "title": "Virtual Machine"
        }, 
        {
            "location": "/installation/#lets-go", 
            "text": "If you want something that works in a few seconds than the  PaaS  page\nis the right manual page!", 
            "title": "Let's go!"
        }, 
        {
            "location": "/installation/basic_php/", 
            "text": "Basic PHP\n\n\nYou may not want to install a webserver in you development machine, but you might\nwant to test your products by yourself and locally before performing the push/deploy.\n\n\nYou can test your products by starting the PHP built-in webserver (inside the project directory):\n\n\nphp -S localhost:8080 -t ./\n\n\n\n\nThis feature is meant for testing purpouse \nONLY\n because it is IDE friendly\nand easy to use without an IDE, but you \nshould avoid\n using PHP webserver\nin a production environment due to its \nreally\n low performance!", 
            "title": "Basic PHP"
        }, 
        {
            "location": "/installation/basic_php/#basic-php", 
            "text": "You may not want to install a webserver in you development machine, but you might\nwant to test your products by yourself and locally before performing the push/deploy.  You can test your products by starting the PHP built-in webserver (inside the project directory):  php -S localhost:8080 -t ./  This feature is meant for testing purpouse  ONLY  because it is IDE friendly\nand easy to use without an IDE, but you  should avoid  using PHP webserver\nin a production environment due to its  really  low performance!", 
            "title": "Basic PHP"
        }, 
        {
            "location": "/installation/php_7_nginx/", 
            "text": "PHP v7 \n nginx\n\n\nThis framework is fully compatible with PHP 7, and you are encouraged to use it.\n\n\nPHP v7 is the PHP version I am using while developing Gishiki.\n\n\nInstallation depends on your system, so read the PHP manual (or google for instructions....).\n\n\nYou will be provided with Ubuntu 16.04 instructions:\n\n\nsudo apt-get install nginx php7.0 php7.0-dev php7.0-mbstring php7.0-xml php7.0-fpm php7.0-mysql php7.0-sqlite php7.0-pgsql php7.0-curl\n\n\n\n\nWhen you are done with the configuration file (/etc/nginx/sites-enabled/default), \nwhich should be basically:\n\n\nserver {\n    listen 80;\n    server_name site.com;\n    root /var/www/html/Gishiki;\n\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        # NOTE: You should have \ncgi.fix_pathinfo = 0;\n in php.ini\n\n        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; # this is important (YOU MUST CHECK FOR THIS FILE!)\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_intercept_errors on;\n    }\n}\n\n\n\n\nyou restart the server and the php service:\n\n\nsudo service nginx restart\nsudo service php7.0-fpm restart\n\n\n\n\nAnd the server should just work!", 
            "title": "PHP 7.0 & nginx"
        }, 
        {
            "location": "/installation/php_7_nginx/#php-v7-nginx", 
            "text": "This framework is fully compatible with PHP 7, and you are encouraged to use it.  PHP v7 is the PHP version I am using while developing Gishiki.  Installation depends on your system, so read the PHP manual (or google for instructions....).  You will be provided with Ubuntu 16.04 instructions:  sudo apt-get install nginx php7.0 php7.0-dev php7.0-mbstring php7.0-xml php7.0-fpm php7.0-mysql php7.0-sqlite php7.0-pgsql php7.0-curl  When you are done with the configuration file (/etc/nginx/sites-enabled/default), \nwhich should be basically:  server {\n    listen 80;\n    server_name site.com;\n    root /var/www/html/Gishiki;\n\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        # NOTE: You should have  cgi.fix_pathinfo = 0;  in php.ini\n\n        fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; # this is important (YOU MUST CHECK FOR THIS FILE!)\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_intercept_errors on;\n    }\n}  you restart the server and the php service:  sudo service nginx restart\nsudo service php7.0-fpm restart  And the server should just work!", 
            "title": "PHP v7 &amp; nginx"
        }, 
        {
            "location": "/installation/basic_nginx/", 
            "text": "Basic nginx\n\n\nYou may want to use nginx.... That's legit and smart, but you already know how to \ndo your job, so just remember to enable PHP and the rewriting engine:\n\n\nserver {\n    listen 80;\n    server_name site.com;\n    root /var/www/html;\n        error_log /var/www/error.log;\n        access_log /var/www/access.log;\n\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        # NOTE: You should have \ncgi.fix_pathinfo = 0;\n in php.ini\n\n        fastcgi_pass unix:/var/run/php5-fpm.sock;\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_intercept_errors on;\n    }\n}\n\n\n\n\nYour server configuration file should be located at /etc/nginx/nginx.conf", 
            "title": "Basic nginx"
        }, 
        {
            "location": "/installation/basic_nginx/#basic-nginx", 
            "text": "You may want to use nginx.... That's legit and smart, but you already know how to \ndo your job, so just remember to enable PHP and the rewriting engine:  server {\n    listen 80;\n    server_name site.com;\n    root /var/www/html;\n        error_log /var/www/error.log;\n        access_log /var/www/access.log;\n\n    index index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        # NOTE: You should have  cgi.fix_pathinfo = 0;  in php.ini\n\n        fastcgi_pass unix:/var/run/php5-fpm.sock;\n        fastcgi_index index.php;\n        include fastcgi.conf;\n        fastcgi_intercept_errors on;\n    }\n}  Your server configuration file should be located at /etc/nginx/nginx.conf", 
            "title": "Basic nginx"
        }, 
        {
            "location": "/installation/basic_apache/", 
            "text": "Basic Apache 2.4\n\n\nIf you are using a debian or ubuntu based distro you have to remember that you\nneed to enable mod_rewrite on apache:\n\n\nsudo a2enmod rewrite\nsudo nano /etc/apache2/sites-available/000-default.conf\nsudo service apache2 restart\n\n\n\n\nYou must have AllowOverride set to \"All\" and not to \"None\" in the file being edited by nano.\n\n\nWhen you are done with nano just ctrl+O, Enter, ctrl+X.\n\n\nYou can simply cut 'n' paste this configuration:\n\n\nVirtualHost *:80\n\n    #ServerName www.example.com\n\n    ServerAdmin webmaster@localhost\n    DocumentRoot /var/www/html\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n        # globally allow .htaccess\n    \nDirectory \n/var/www/html\n\n        AllowOverride All\n    \n/Directory\n\n\n/VirtualHost\n\n\n# vim: syntax=apache ts=4 sw=4 sts=4 sr noet\n\n\n\n\nYou can just copy the .htaccess file from the Gishiki main rapository to your\napplication root, here I am reporting it:\n\n\nIfModule mod_rewrite.c\n\n    Options +FollowSymLinks\n    RewriteEngine On\n    RewriteCond %{REQUEST_FILENAME} !-f\n    RewriteCond %{REQUEST_FILENAME} !-d\n    RewriteRule ^ index.php [QSA,L]\n\n/IfModule\n\n\n\n\n\nYou can even be more aggressive here:\n\n\nIfModule mod_rewrite.c\n\n    RewriteEngine On\n    RewriteRule ^ index.php [QSA,L]\n\n/IfModule\n\n\n#allow requests from outside the domain\nHeader add Access-Control-Allow-Origin \n*\n\nHeader add Access-Control-Allow-Headers \norigin, x-requested-with, content-type\n\nHeader add Access-Control-Allow-Methods \nPUT, GET, POST, DELETE, OPTIONS\n\n\n\n\n\nThat shorted version will call the framework even if the client is asking for a\nresource that is a file inside you webroot!\n\n\nRemember that using .htaccess slows down your apache server,\nso if you have access to the configuration file of your production server you\n\nshould\n embed the provided \".htaccess\".", 
            "title": "Basic apache"
        }, 
        {
            "location": "/installation/basic_apache/#basic-apache-24", 
            "text": "If you are using a debian or ubuntu based distro you have to remember that you\nneed to enable mod_rewrite on apache:  sudo a2enmod rewrite\nsudo nano /etc/apache2/sites-available/000-default.conf\nsudo service apache2 restart  You must have AllowOverride set to \"All\" and not to \"None\" in the file being edited by nano.  When you are done with nano just ctrl+O, Enter, ctrl+X.  You can simply cut 'n' paste this configuration:  VirtualHost *:80 \n    #ServerName www.example.com\n\n    ServerAdmin webmaster@localhost\n    DocumentRoot /var/www/html\n\n    ErrorLog ${APACHE_LOG_DIR}/error.log\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\n\n        # globally allow .htaccess\n     Directory  /var/www/html \n        AllowOverride All\n     /Directory  /VirtualHost \n\n# vim: syntax=apache ts=4 sw=4 sts=4 sr noet  You can just copy the .htaccess file from the Gishiki main rapository to your\napplication root, here I am reporting it:  IfModule mod_rewrite.c \n    Options +FollowSymLinks\n    RewriteEngine On\n    RewriteCond %{REQUEST_FILENAME} !-f\n    RewriteCond %{REQUEST_FILENAME} !-d\n    RewriteRule ^ index.php [QSA,L] /IfModule   You can even be more aggressive here:  IfModule mod_rewrite.c \n    RewriteEngine On\n    RewriteRule ^ index.php [QSA,L] /IfModule \n\n#allow requests from outside the domain\nHeader add Access-Control-Allow-Origin  * \nHeader add Access-Control-Allow-Headers  origin, x-requested-with, content-type \nHeader add Access-Control-Allow-Methods  PUT, GET, POST, DELETE, OPTIONS   That shorted version will call the framework even if the client is asking for a\nresource that is a file inside you webroot!  Remember that using .htaccess slows down your apache server,\nso if you have access to the configuration file of your production server you should  embed the provided \".htaccess\".", 
            "title": "Basic Apache 2.4"
        }, 
        {
            "location": "/installation/basic_lighttpd/", 
            "text": "Basic lighttpd\n\n\nIf you are planning to use lighttpd as webserver for your application you\n\nMUST\n be provided with instructions:\n\n\nurl.rewrite-if-not-file = (\n(.*)\n =\n \n/index.php/$0\n)\n\n\n\n\nThere you are! You just need to paste that code into the configuration file of lighttpd!\n\n\nThis requires lighttpd \n= 1.4.24.", 
            "title": "Basic lighttpd"
        }, 
        {
            "location": "/installation/basic_lighttpd/#basic-lighttpd", 
            "text": "If you are planning to use lighttpd as webserver for your application you MUST  be provided with instructions:  url.rewrite-if-not-file = ( (.*)  =   /index.php/$0 )  There you are! You just need to paste that code into the configuration file of lighttpd!  This requires lighttpd  = 1.4.24.", 
            "title": "Basic lighttpd"
        }, 
        {
            "location": "/installation/basic_iis/", 
            "text": "Basic IIS\n\n\nYou shouldn't be using IIS, really, just... \ndon't\n.\n\n\nIf \nREALLY HAVE TO\n use IIS and you have no other choice make sure you have a\nfile called Web.config alongside with an index.php file in the same\npublic-accessible directory.\n\n\nThe Web.config file should contain this code:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nconfiguration\n\n    \nsystem.webServer\n\n        \nrewrite\n\n            \nrules\n\n                \nrule name=\nslim\n patternSyntax=\nWildcard\n\n                    \nmatch url=\n*\n /\n\n                    \nconditions\n\n                        \nadd input=\n{REQUEST_FILENAME}\n matchType=\nIsFile\n negate=\ntrue\n /\n\n                        \nadd input=\n{REQUEST_FILENAME}\n matchType=\nIsDirectory\n negate=\ntrue\n /\n\n                    \n/conditions\n\n                    \naction type=\nRewrite\n url=\nindex.php\n /\n\n                \n/rule\n\n            \n/rules\n\n        \n/rewrite\n\n    \n/system.webServer\n\n\n/configuration\n\n\n\n\n\nHowever, you \nREALLY\n should keep distances from IIS (at least when using it with PHP)!", 
            "title": "Basic IIS"
        }, 
        {
            "location": "/installation/basic_iis/#basic-iis", 
            "text": "You shouldn't be using IIS, really, just...  don't .  If  REALLY HAVE TO  use IIS and you have no other choice make sure you have a\nfile called Web.config alongside with an index.php file in the same\npublic-accessible directory.  The Web.config file should contain this code:  ?xml version= 1.0  encoding= UTF-8 ?  configuration \n     system.webServer \n         rewrite \n             rules \n                 rule name= slim  patternSyntax= Wildcard \n                     match url= *  / \n                     conditions \n                         add input= {REQUEST_FILENAME}  matchType= IsFile  negate= true  / \n                         add input= {REQUEST_FILENAME}  matchType= IsDirectory  negate= true  / \n                     /conditions \n                     action type= Rewrite  url= index.php  / \n                 /rule \n             /rules \n         /rewrite \n     /system.webServer  /configuration   However, you  REALLY  should keep distances from IIS (at least when using it with PHP)!", 
            "title": "Basic IIS"
        }, 
        {
            "location": "/installation/composer/", 
            "text": "Composer\n\n\nAs promised Gishiki is not meant to replace your favourite tools:\nyou can still use all of them!\n\n\nDoctrine? Propel? Zend framework components? Symfony components? No problem!\n\n\nYou have to install them and you do that using composer! If you don't have composer run:\n\n\nsudo wget https://getcomposer.org/composer.phar\nsudo chmod +x composer.phar\nsudo mv composer.phar /usr/local/bin/composer\n\n\n\n\nRemember that composer is essential to run Gishiki: composer is what loads the\nentire framework, manages its dependencies and keep updated the framework!\n\n\nBootstrapping an application\n\n\nYou like digging immediatly into development? No problem!\n\n\nYou will have to use composer to start up your new project!\n\n\ncomposer init # remember to specify neroreflex/gishiki\ncomposer install --no-dev\n./vendor/bin/gishiki new application\n\n\n\n\nnice and easy! Good work.", 
            "title": "Composer"
        }, 
        {
            "location": "/installation/composer/#composer", 
            "text": "As promised Gishiki is not meant to replace your favourite tools:\nyou can still use all of them!  Doctrine? Propel? Zend framework components? Symfony components? No problem!  You have to install them and you do that using composer! If you don't have composer run:  sudo wget https://getcomposer.org/composer.phar\nsudo chmod +x composer.phar\nsudo mv composer.phar /usr/local/bin/composer  Remember that composer is essential to run Gishiki: composer is what loads the\nentire framework, manages its dependencies and keep updated the framework!", 
            "title": "Composer"
        }, 
        {
            "location": "/installation/composer/#bootstrapping-an-application", 
            "text": "You like digging immediatly into development? No problem!  You will have to use composer to start up your new project!  composer init # remember to specify neroreflex/gishiki\ncomposer install --no-dev\n./vendor/bin/gishiki new application  nice and easy! Good work.", 
            "title": "Bootstrapping an application"
        }, 
        {
            "location": "/installation/paas/", 
            "text": "PaaS\n\n\nPaaS\n stands for: \nP\nlatform \na\ns \na\n \nS\nervice.\n\n\nA PaaS is a service that give life to your application, which is hosted in a\ncloud (often sandboxed) environment, giving you additional protection to your\napplication and abstracting away from you the problem of scaling large-scale\nserver intensive applications.\n\n\nA PaaS provider ofter adds to its service a set of utilities that simplify your\nlife, especially with automatic content delivery and/or application update:\nfor example Heroku automatically Sync your application with its GitHub repository\nand automatically deploy your application on each push if it passes the\nautomatic integration testing set!\n\n\nA small list of supported PaaS may be:\n - Heroku\n - OpenShift\n - Google AppEngine\n - PagodaBox\n - elastx\n - Microsoft Azure\n\n\nBut there are many, many more of them: everything that can run PHP 5.4 will work!\n\n\nGetting Started\n\n\nGishiki is tested costantly with Heroku because Heroku is fantastic\nand empowers your application with a lot of simple tools without forcing you to\nmaintain a server or a container!\n\n\nSetting up a perfectly working Heroku/OpenShift application is super-easy:\n\n\n\n\nRegister \n Login to your PaaS provider website\n\n\nCreate a new application using your PaaS provider website\n\n\nSetup auto-deploy using your PaaS provider website\n\n\nCreate a new application using \ncomposer\n\n\n\n\nEdit locally your application, commit and when a \ngit push\n is performed to GitHub your\nHeroku/openShift application is automatically updated! Have fun \n3.\n\n\nDatabase\n\n\nYou are free to host your database everywhere, but Heroku, OpenShift and many\nothers PaaS are providing database support as simple add-ons to your application,\nand Gishiki is able to take advantage of those add-ons!\n\n\nFor example you can pick the \"Heroku Postgres\" add-on to have for free a PostgreSQL\ndatabase binded with your application!", 
            "title": "PaaS"
        }, 
        {
            "location": "/installation/paas/#paas", 
            "text": "PaaS  stands for:  P latform  a s  a   S ervice.  A PaaS is a service that give life to your application, which is hosted in a\ncloud (often sandboxed) environment, giving you additional protection to your\napplication and abstracting away from you the problem of scaling large-scale\nserver intensive applications.  A PaaS provider ofter adds to its service a set of utilities that simplify your\nlife, especially with automatic content delivery and/or application update:\nfor example Heroku automatically Sync your application with its GitHub repository\nand automatically deploy your application on each push if it passes the\nautomatic integration testing set!  A small list of supported PaaS may be:\n - Heroku\n - OpenShift\n - Google AppEngine\n - PagodaBox\n - elastx\n - Microsoft Azure  But there are many, many more of them: everything that can run PHP 5.4 will work!", 
            "title": "PaaS"
        }, 
        {
            "location": "/installation/paas/#getting-started", 
            "text": "Gishiki is tested costantly with Heroku because Heroku is fantastic\nand empowers your application with a lot of simple tools without forcing you to\nmaintain a server or a container!  Setting up a perfectly working Heroku/OpenShift application is super-easy:   Register   Login to your PaaS provider website  Create a new application using your PaaS provider website  Setup auto-deploy using your PaaS provider website  Create a new application using  composer   Edit locally your application, commit and when a  git push  is performed to GitHub your\nHeroku/openShift application is automatically updated! Have fun  3.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/installation/paas/#database", 
            "text": "You are free to host your database everywhere, but Heroku, OpenShift and many\nothers PaaS are providing database support as simple add-ons to your application,\nand Gishiki is able to take advantage of those add-ons!  For example you can pick the \"Heroku Postgres\" add-on to have for free a PostgreSQL\ndatabase binded with your application!", 
            "title": "Database"
        }, 
        {
            "location": "/apidoc/", 
            "text": "API Documentation\n\n\nThe API Documentation is automatically build from PHPDoc comments into the Gishiki source code.\n\n\nThe API Documentation is the most advanced and up-to-date documentation you can find,\nbut you will need to know how to use Gishiki before understanding that documentation.\n\n\nThe API Documentation is perfect to have an overview of what you can do using Gishiki and \nhow Gishiki is organized internally.\n\n\nAccessing the docs\n\n\nYou can access the API Documentation from \nhere\n.\n\n\nIf you are totally unable to understand what is described there just don't worry about\nit, you can do amazing things even without reading that thing!", 
            "title": "API"
        }, 
        {
            "location": "/apidoc/#api-documentation", 
            "text": "The API Documentation is automatically build from PHPDoc comments into the Gishiki source code.  The API Documentation is the most advanced and up-to-date documentation you can find,\nbut you will need to know how to use Gishiki before understanding that documentation.  The API Documentation is perfect to have an overview of what you can do using Gishiki and \nhow Gishiki is organized internally.", 
            "title": "API Documentation"
        }, 
        {
            "location": "/apidoc/#accessing-the-docs", 
            "text": "You can access the API Documentation from  here .  If you are totally unable to understand what is described there just don't worry about\nit, you can do amazing things even without reading that thing!", 
            "title": "Accessing the docs"
        }, 
        {
            "location": "/usage/configuration/", 
            "text": "Configuration\n\n\nGishiki is a bit tricky to configure, but don't worry: you just need to edit\nwhat you don't like as the \ngishiki CLI\n takes care of bootstrapping\na fully-working configuration.\n\n\nthe real configuration file is stored inside the application root directory and is called settings.json\n\n\nIt has a fixed (minumum) structure:\n\n\n{\n    \ngeneral\n: {\n        \ndevelopment\n: true,\n        \nautolog\n: null\n    },\n\n    \nsecurity\n: {\n        \nserverPassword\n: \n{{@MASTER_KEY}}\n,\n        \nserverKey\n: \n{{@SERVER_KEY}}\n\n    },\n\n    \nconnections\n: [\n        {\n            \nname\n: \ndefault\n,\n            \nquery\n: \nsqlite://relative/path/to/db.sqlite\n\n        },\n        {\n            \nname\n: \ndebug\n,\n            \nquery\n: \nsqlite:///absolute/path/to/db.sqlite\n\n        }\n    ]\n}\n\n\n\n\nAs you might have thought those {{@VAR_NAMES}} are replaced with constants defined\nin your environment AND/OR Heroku \"Config Variables\"!\n\n\nThis is a \nGREAT\n feature that keeps \nSECRET\n your database connection descriptor and\nyour master server key while allowing application portability among illimitate environments!\n\n\nAutomatic Logger\n\n\nThe automatic logger is the logger automatically used to store log entries generated by\nan exception.\n\n\nTo understand how to connect a logger it is important to read the \nLogging\n chapter of this manual.\n\n\nUsing null (as in the above example) will discard each log entry.\n\n\nServer Key\n\n\nThe server key is a serialized RSA private key as OpenSSL can deserialize it:\na PEM formatted private key or PEM encoded certificate/private key.\n\n\nThe serialized key \nCANNOT\n be password encrypted.\n\n\nThe server key can be embedded into the JSON, but it may not be the best solution:\nyou should either create an environment variable holding the serialized key calling it MASTER_KEY\nand recycle the example code, or giving a file path to the serialized key, for example:\n\"file:///absolute/path/to/file.pem\" or \"file://relative/path/to/file.pem\".\n\n\nThe file path can also be the value of the environment variable, but that is not suggested.\n\n\nThe private key can be of any length and power of two, however 4096 or bigger\nis suggested.\n\n\nopenssl genrsa -out relative/path/to/file.pem 4096\n\n\n\n\nThat is the OpenSSL CLI command that may be used to generate a valid RSA private key.\n\n\nServer Password\n\n\nThe server password is what will be used as the default server symmetric key.\n\n\nUnlike the server private key, the server password has a fixed length and it must\nbe 64 characters long!", 
            "title": "Configuration"
        }, 
        {
            "location": "/usage/configuration/#configuration", 
            "text": "Gishiki is a bit tricky to configure, but don't worry: you just need to edit\nwhat you don't like as the  gishiki CLI  takes care of bootstrapping\na fully-working configuration.  the real configuration file is stored inside the application root directory and is called settings.json  It has a fixed (minumum) structure:  {\n     general : {\n         development : true,\n         autolog : null\n    },\n\n     security : {\n         serverPassword :  {{@MASTER_KEY}} ,\n         serverKey :  {{@SERVER_KEY}} \n    },\n\n     connections : [\n        {\n             name :  default ,\n             query :  sqlite://relative/path/to/db.sqlite \n        },\n        {\n             name :  debug ,\n             query :  sqlite:///absolute/path/to/db.sqlite \n        }\n    ]\n}  As you might have thought those {{@VAR_NAMES}} are replaced with constants defined\nin your environment AND/OR Heroku \"Config Variables\"!  This is a  GREAT  feature that keeps  SECRET  your database connection descriptor and\nyour master server key while allowing application portability among illimitate environments!", 
            "title": "Configuration"
        }, 
        {
            "location": "/usage/configuration/#automatic-logger", 
            "text": "The automatic logger is the logger automatically used to store log entries generated by\nan exception.  To understand how to connect a logger it is important to read the  Logging  chapter of this manual.  Using null (as in the above example) will discard each log entry.", 
            "title": "Automatic Logger"
        }, 
        {
            "location": "/usage/configuration/#server-key", 
            "text": "The server key is a serialized RSA private key as OpenSSL can deserialize it:\na PEM formatted private key or PEM encoded certificate/private key.  The serialized key  CANNOT  be password encrypted.  The server key can be embedded into the JSON, but it may not be the best solution:\nyou should either create an environment variable holding the serialized key calling it MASTER_KEY\nand recycle the example code, or giving a file path to the serialized key, for example:\n\"file:///absolute/path/to/file.pem\" or \"file://relative/path/to/file.pem\".  The file path can also be the value of the environment variable, but that is not suggested.  The private key can be of any length and power of two, however 4096 or bigger\nis suggested.  openssl genrsa -out relative/path/to/file.pem 4096  That is the OpenSSL CLI command that may be used to generate a valid RSA private key.", 
            "title": "Server Key"
        }, 
        {
            "location": "/usage/configuration/#server-password", 
            "text": "The server password is what will be used as the default server symmetric key.  Unlike the server private key, the server password has a fixed length and it must\nbe 64 characters long!", 
            "title": "Server Password"
        }, 
        {
            "location": "/usage/routing/", 
            "text": "Routing\n\n\nWhen a request arrives the framework must fulfill it.\n\n\nThe framework automatically maps a request to a resource located at \"https://site.com/Home\" into \"/Home\" (GET request).\n\n\nThe /Home string is the URI of the requested resource, the GET request is the HTTP method used to query that resource...\nthe question is....\n\n\nHow do I route that request to what I want to serve? The answer is: using the router!\n\n\nThe router is that fantastic component empowering your user-friendly URLs!\n\n\nDifferent methods\n\n\nAs for HTTP standards a client can perform a resource request using these verbs:\n\n\n\n\nGET identified as Route::GET\n\n\nPOST  identified as Route::POST\n\n\nDELETE identified as Route::DELETE\n\n\nPUT identified as Route::PUT\n\n\nHEAD identified as Route::HEAD\n\n\nPATCH identified as Route::PATCH\n\n\nOPTIONS identified as Route::OPTIONS\n\n\n\n\nWhen you set a routing rule (either static or dynamic) you have to select the\nverb that you want to be served in that route.\n\n\nThis is particulary handy when creating a RESTful service.\n\n\nStatic Rules\n\n\nLet's see how to create a custom route:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for \nhttps://site.com/\n (the homepage)\n\n    //let's just forget about MVC pattern this time :)\n    echo \nHello, World!\n;\n});\n\n\n\n\nTo try this rule out you have to open index.php and paste the provided code into \nit and direct your browser to: https://site.com (the trailing / is automatically added).\n\n\nDynamic Rules\n\n\nThis route is really simple: just an URI check... but you are creating a dynamic application,\nand URIs cannot be static URIs every time, in fact sooner or later you will need to capture a parameter passed\nas a parameter with the URL.\n\n\nLet's just consider this simple example:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get(\n/Hello/{name_surname}\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for \nhttps://site.com/User/urName+urSurname\n\n\n    //nice to meet you!\n    $response-\nwrite(\nHello, \n.$arguments-\n{\nname_surname\n}.\n!\n);\n});\n\nRoute::get(\n/Home/{name}\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for \nhttps://site.com/Home/some_name\n\n\n    //nice to meet you!\n    $response-\nwrite(\nHello, \n.$arguments-\nname.\n!\n);\n});\n\n\n\n\nYou already know what you are going to do, right? :D\n\n\nhttps://site.com/Home/your_name and you will see \"Hello, your_name!\" nothing complex here, right?\n\n\nCustom Dynamic Rules\n\n\nYou might want to catch something more specific than just \"everything but '/'\",\nsay for example an integer or an email address:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get(\n/Hello/{user_email:email}\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for \nhttps://site.com/Hello/yourEmail%40address.com\n\n\n    //send that mail!\n    if (!mail($arguments-\nuser_email , \nGishiki RESTful test\n , \nWelcome to my RESTful test service \n3\n)) {\n        $default_logger = new Logger();\n        $default_logger-\nwarning(\nAn e-mail is missing :(\n);\n    }\n});\n\n\n\n\nThat's great isn't it? Actually what you can catch is:\n\n\n\n\n'default' a generic string\n\n\n'email' an email address\n\n\n'integer' an integer number\n\n\n\n\nAll request methods\n\n\nSometimes you may need to register a route that responds to all HTTP verbs, you\nare allowed to do that by using 'any':\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //do something general with your homepage!\n});\n\n\n\n\nthe action is taken if that URI is hit, regardless of the method the client used\nto perform the request.\n\n\nTwo or more request methods\n\n\nAn interesting feature of the router is how you create a route for two or more\nrequest methods:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::match([Route::GET, Route::POST], \n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //you want your homepage to be reached only with get and post\n});\n\n\n\n\nthe action is taken if that URI is hit only when using get or post request method.\n\n\nError catching\n\n\nYou know, things doesn't always go as you want: it is necessary to think about\nunexpected circumstances. You do it by setting an error callback,\nwhich is nothing more than a bit special routing rule:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for an unrouted URI\n\n    //error message!\n    $response-\nwrite(\nSorry man, you are asking for something I can't give you :(\n);\n});\n\n\n\n\nAs you can see an error routing rule (or error callback) is exactly any other URI\nand follows the same exact rules, however for known errors the HTTP status code is\nautomatically changed (for example if a Route::NOT_FOUND URI is catched 404 Not Found\nis added automatically to the response).\n\n\nYou cannot change this behaviour, but you can change the status code:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //this is what will be executed when the client asks for an unrouted URI\n    $response-\nwithStatus(500);\n\n    //error message!\n    $response-\nwrite(\nSorry man, you are asking for something I can't give you :(\n);\n});\n\n\n\n\nA bit stange to send to the client a 500 Internal Server Error for a missing\nresource, but nothing stops you from doing that.\n\n\nLimitation\n\n\nYou cannot route URIs that start with /api/ or /service/ because they are reserved for web services (explained in a different chapter).\n\n\nYou cannot match something that has a slash '/' character using a dynamic placeholder: {name} cannot capture something like \"mario/rossi\".\n\n\nConclusions\n\n\nThe router is the fastest and easiest component within Gishiki,\nbecause it is the first component that is used and the only one you \nREALLY HAVE TO\n use.\n\n\nThis means that you are now good to go... Everything you \nMUST\n know in order to use Gishiki ends here.\n\n\nEverything else is a plus you may need to accelerate the development of your projects,\nalthough you should really learn how to deal with the \nRequest\n and the \nResponse\n objects passed to you.", 
            "title": "Router"
        }, 
        {
            "location": "/usage/routing/#routing", 
            "text": "When a request arrives the framework must fulfill it.  The framework automatically maps a request to a resource located at \"https://site.com/Home\" into \"/Home\" (GET request).  The /Home string is the URI of the requested resource, the GET request is the HTTP method used to query that resource...\nthe question is....  How do I route that request to what I want to serve? The answer is: using the router!  The router is that fantastic component empowering your user-friendly URLs!", 
            "title": "Routing"
        }, 
        {
            "location": "/usage/routing/#different-methods", 
            "text": "As for HTTP standards a client can perform a resource request using these verbs:   GET identified as Route::GET  POST  identified as Route::POST  DELETE identified as Route::DELETE  PUT identified as Route::PUT  HEAD identified as Route::HEAD  PATCH identified as Route::PATCH  OPTIONS identified as Route::OPTIONS   When you set a routing rule (either static or dynamic) you have to select the\nverb that you want to be served in that route.  This is particulary handy when creating a RESTful service.", 
            "title": "Different methods"
        }, 
        {
            "location": "/usage/routing/#static-rules", 
            "text": "Let's see how to create a custom route:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for  https://site.com/  (the homepage)\n\n    //let's just forget about MVC pattern this time :)\n    echo  Hello, World! ;\n});  To try this rule out you have to open index.php and paste the provided code into \nit and direct your browser to: https://site.com (the trailing / is automatically added).", 
            "title": "Static Rules"
        }, 
        {
            "location": "/usage/routing/#dynamic-rules", 
            "text": "This route is really simple: just an URI check... but you are creating a dynamic application,\nand URIs cannot be static URIs every time, in fact sooner or later you will need to capture a parameter passed\nas a parameter with the URL.  Let's just consider this simple example:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get( /Hello/{name_surname} ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for  https://site.com/User/urName+urSurname \n\n    //nice to meet you!\n    $response- write( Hello,  .$arguments- { name_surname }. ! );\n});\n\nRoute::get( /Home/{name} ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for  https://site.com/Home/some_name \n\n    //nice to meet you!\n    $response- write( Hello,  .$arguments- name. ! );\n});  You already know what you are going to do, right? :D  https://site.com/Home/your_name and you will see \"Hello, your_name!\" nothing complex here, right?", 
            "title": "Dynamic Rules"
        }, 
        {
            "location": "/usage/routing/#custom-dynamic-rules", 
            "text": "You might want to catch something more specific than just \"everything but '/'\",\nsay for example an integer or an email address:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::get( /Hello/{user_email:email} ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for  https://site.com/Hello/yourEmail%40address.com \n\n    //send that mail!\n    if (!mail($arguments- user_email ,  Gishiki RESTful test  ,  Welcome to my RESTful test service  3 )) {\n        $default_logger = new Logger();\n        $default_logger- warning( An e-mail is missing :( );\n    }\n});  That's great isn't it? Actually what you can catch is:   'default' a generic string  'email' an email address  'integer' an integer number", 
            "title": "Custom Dynamic Rules"
        }, 
        {
            "location": "/usage/routing/#all-request-methods", 
            "text": "Sometimes you may need to register a route that responds to all HTTP verbs, you\nare allowed to do that by using 'any':  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //do something general with your homepage!\n});  the action is taken if that URI is hit, regardless of the method the client used\nto perform the request.", 
            "title": "All request methods"
        }, 
        {
            "location": "/usage/routing/#two-or-more-request-methods", 
            "text": "An interesting feature of the router is how you create a route for two or more\nrequest methods:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::match([Route::GET, Route::POST],  / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //you want your homepage to be reached only with get and post\n});  the action is taken if that URI is hit only when using get or post request method.", 
            "title": "Two or more request methods"
        }, 
        {
            "location": "/usage/routing/#error-catching", 
            "text": "You know, things doesn't always go as you want: it is necessary to think about\nunexpected circumstances. You do it by setting an error callback,\nwhich is nothing more than a bit special routing rule:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for an unrouted URI\n\n    //error message!\n    $response- write( Sorry man, you are asking for something I can't give you :( );\n});  As you can see an error routing rule (or error callback) is exactly any other URI\nand follows the same exact rules, however for known errors the HTTP status code is\nautomatically changed (for example if a Route::NOT_FOUND URI is catched 404 Not Found\nis added automatically to the response).  You cannot change this behaviour, but you can change the status code:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //this is what will be executed when the client asks for an unrouted URI\n    $response- withStatus(500);\n\n    //error message!\n    $response- write( Sorry man, you are asking for something I can't give you :( );\n});  A bit stange to send to the client a 500 Internal Server Error for a missing\nresource, but nothing stops you from doing that.", 
            "title": "Error catching"
        }, 
        {
            "location": "/usage/routing/#limitation", 
            "text": "You cannot route URIs that start with /api/ or /service/ because they are reserved for web services (explained in a different chapter).  You cannot match something that has a slash '/' character using a dynamic placeholder: {name} cannot capture something like \"mario/rossi\".", 
            "title": "Limitation"
        }, 
        {
            "location": "/usage/routing/#conclusions", 
            "text": "The router is the fastest and easiest component within Gishiki,\nbecause it is the first component that is used and the only one you  REALLY HAVE TO  use.  This means that you are now good to go... Everything you  MUST  know in order to use Gishiki ends here.  Everything else is a plus you may need to accelerate the development of your projects,\nalthough you should really learn how to deal with the  Request  and the  Response  objects passed to you.", 
            "title": "Conclusions"
        }, 
        {
            "location": "/usage/request/", 
            "text": "Request\n\n\nThe \nGishiki\\HttpKernel\\Request\n class is used to fully represent an HTTP request.\n\n\nThe Request class is PSR-7 conformant and follows that specification sheet.\n\n\nRequest Method\n\n\nWhen an HTTP request is sent to the server the client has to specify the type of the\nrequest, that request type is called 'method'.\n\n\nUsually you work with following methods:\n\n\n\n\nGET\n\n\nPOST\n\n\nPUT\n\n\nDELETE\n\n\nHEAD\n\n\nPATCH\n\n\nOPTIONS\n\n\n\n\nbut your application can also support your own methods!\n\n\nYou can inspect the HTTP request\u2019s method with the Request object method\nappropriately named getMethod()\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/method_test\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $method = $request-\ngetMethod();\n\n    //this is what will be executed when the client asks for an unrouted URI\n    $response-\nwithStatus(200);\n\n    //error message!\n    $response-\nwrite(\nYou have used the \n.$method.\n method to fetch this page!\n);\n});\n\n\n\n\nHowever you can override the standard HTTP method including in the header an\nX-Http-Method-Override property, for example:\n\n\nPOST /path HTTP/1.1\nHost: example.com\nContent-type: application/json\nX-Http-Method-Override: PUT\n\n\n\n\nAnd the code before will return the string \"PUT\", and not the string \"POST\".\n\n\nIf you want to retrive the real HTTP method used (non-overridden) you can do it\nusing another function which is called getOriginalMethod():\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/method_test\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $method = $request-\ngetMethod();\n    $origin_method = $request-\ngetOriginalMethod();\n\n    //this is what will be executed when the client asks for an unrouted URI\n    $response-\nwithStatus(200);\n\n    //error message!\n    $response-\nwrite(\nYou have used the \n.$method.\n method to fetch this page!\\n\n);\n\n    if ($method != $origin_method) \n        $response-\nwrite(\nHowever the request used the \n.$origin_method.\n method to fetch this page!\\n\n);\n});\n\n\n\n\nIf you try overriding the HTTP method you will see the you will be found cheating :D\n\n\nRequest URI\n\n\nEvery HTTP request has a URI that identifies the requested application resource.\nThe HTTP request URI is composite of several parts:\n\n\n\n\nScheme (e.g. http or https)\n\n\nHost (e.g. example.com)\n\n\nPort (e.g. 80 or 443)\n\n\nPath (e.g. /users/1)\n\n\nQuery string (e.g. sort=created\ndir=asc)\n\n\n\n\nYou can fetch the Request object\u2019s URI using its getUri() method:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/method_test\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //get the URI of the current request\n    $uri = $request-\ngetUri();\n\n    //do something with this URI\n});\n\n\n\n\nOperation allowed on an URI are:\n\n\n\n\ngetScheme()\n\n\ngetAuthority()\n\n\ngetUserInfo()\n\n\ngetHost()\n\n\ngetPort()\n\n\ngetPath()\n\n\ngetBasePath()\n\n\ngetQuery()\n\n\ngetFragment()\n\n\ngetBaseUrl()\n\n\ngetQueryParams()\n\n\n\n\nwhere getQueryParams() returns an associative array, getQuery() returns the complete\nquery string and getBaseUrl() the complete URL of the request.\n\n\nRequest Headers\n\n\nHeaders are metadata that describe the HTTP request but are not visible in the\nrequest\u2019s body.\n\n\nEach header can contain more values: this is why the velue of a single header is\nrepresented as a non-associative array.\n\n\nYou can have the complete list of headers, in form of an associative array by\ncalling the getHeaders() function the interested request.\n\n\nA simple example can be:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    foreach ($request-\ngetHeaders() as $name =\n $values) {\n        $response-\nwrite(\nname: \n. $name . \n =\n values:\n . implode(\n, \n, $values));\n    }\n});\n\n\n\n\nseparing each value of the request with a comma is equal is equal to calling the\ngetHeaderLine('header_name') function on the interested request.\n\n\nThe previous example can be rewritten as:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    foreach (array_keys($request-\ngetHeaders()) as $name) {\n        $response-\nwrite(\nname: \n. $name . \n =\n values:\n . $request-\ngetHeaderLine($name);\n    }\n});\n\n\n\n\nYou can test the existance of a given header calling the hasHeader('header_name')\nfunction.\n\n\nIf the result is true you can safely call the getHeader('header_name') function\nthat will return the non-associative array representing the header values.\n\n\nRequest Body\n\n\nAn HTTP request may have a body following its header.\n\n\nThat body is useful when creating a RESTful service, because it may contains lots\nof information about the requested action.\n\n\nWithin Gishiki you can access the body of the interested request as a stream\nPSR-7 compilant. You can obtain that stream calling the getBody() function.\n\n\nLet's look into an example:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //get the body stream\n    $body = $request-\ngetBody();\n\n    //rewind the stream (aka reset the cursor at the beginning of the stream)\n    $body-\nrewind();\n\n    //read the entire request body\n    $request = \n;\n    while (!$body-\neof()) {\n        $request .= read(1);\n    }\n\n    //have fun with your request body!\n});\n\n\n\n\nI know what you are thinking... You could parse that request body to obtain\nsomething like an array or a class that you can use within your application....\n\n\nWell, if that's the case you may appreciate the fact that Gishiki does this\nin your place!\n\n\nTo trigger the request body automatic parsing you can use the getParsedBody()\nfunction that triggers the better parser for the given 'Content-type' header!", 
            "title": "Request"
        }, 
        {
            "location": "/usage/request/#request", 
            "text": "The  Gishiki\\HttpKernel\\Request  class is used to fully represent an HTTP request.  The Request class is PSR-7 conformant and follows that specification sheet.", 
            "title": "Request"
        }, 
        {
            "location": "/usage/request/#request-method", 
            "text": "When an HTTP request is sent to the server the client has to specify the type of the\nrequest, that request type is called 'method'.  Usually you work with following methods:   GET  POST  PUT  DELETE  HEAD  PATCH  OPTIONS   but your application can also support your own methods!  You can inspect the HTTP request\u2019s method with the Request object method\nappropriately named getMethod()  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /method_test ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $method = $request- getMethod();\n\n    //this is what will be executed when the client asks for an unrouted URI\n    $response- withStatus(200);\n\n    //error message!\n    $response- write( You have used the  .$method.  method to fetch this page! );\n});  However you can override the standard HTTP method including in the header an\nX-Http-Method-Override property, for example:  POST /path HTTP/1.1\nHost: example.com\nContent-type: application/json\nX-Http-Method-Override: PUT  And the code before will return the string \"PUT\", and not the string \"POST\".  If you want to retrive the real HTTP method used (non-overridden) you can do it\nusing another function which is called getOriginalMethod():  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /method_test ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $method = $request- getMethod();\n    $origin_method = $request- getOriginalMethod();\n\n    //this is what will be executed when the client asks for an unrouted URI\n    $response- withStatus(200);\n\n    //error message!\n    $response- write( You have used the  .$method.  method to fetch this page!\\n );\n\n    if ($method != $origin_method) \n        $response- write( However the request used the  .$origin_method.  method to fetch this page!\\n );\n});  If you try overriding the HTTP method you will see the you will be found cheating :D", 
            "title": "Request Method"
        }, 
        {
            "location": "/usage/request/#request-uri", 
            "text": "Every HTTP request has a URI that identifies the requested application resource.\nThe HTTP request URI is composite of several parts:   Scheme (e.g. http or https)  Host (e.g. example.com)  Port (e.g. 80 or 443)  Path (e.g. /users/1)  Query string (e.g. sort=created dir=asc)   You can fetch the Request object\u2019s URI using its getUri() method:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /method_test ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //get the URI of the current request\n    $uri = $request- getUri();\n\n    //do something with this URI\n});  Operation allowed on an URI are:   getScheme()  getAuthority()  getUserInfo()  getHost()  getPort()  getPath()  getBasePath()  getQuery()  getFragment()  getBaseUrl()  getQueryParams()   where getQueryParams() returns an associative array, getQuery() returns the complete\nquery string and getBaseUrl() the complete URL of the request.", 
            "title": "Request URI"
        }, 
        {
            "location": "/usage/request/#request-headers", 
            "text": "Headers are metadata that describe the HTTP request but are not visible in the\nrequest\u2019s body.  Each header can contain more values: this is why the velue of a single header is\nrepresented as a non-associative array.  You can have the complete list of headers, in form of an associative array by\ncalling the getHeaders() function the interested request.  A simple example can be:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    foreach ($request- getHeaders() as $name =  $values) {\n        $response- write( name:  . $name .   =  values:  . implode( ,  , $values));\n    }\n});  separing each value of the request with a comma is equal is equal to calling the\ngetHeaderLine('header_name') function on the interested request.  The previous example can be rewritten as:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    foreach (array_keys($request- getHeaders()) as $name) {\n        $response- write( name:  . $name .   =  values:  . $request- getHeaderLine($name);\n    }\n});  You can test the existance of a given header calling the hasHeader('header_name')\nfunction.  If the result is true you can safely call the getHeader('header_name') function\nthat will return the non-associative array representing the header values.", 
            "title": "Request Headers"
        }, 
        {
            "location": "/usage/request/#request-body", 
            "text": "An HTTP request may have a body following its header.  That body is useful when creating a RESTful service, because it may contains lots\nof information about the requested action.  Within Gishiki you can access the body of the interested request as a stream\nPSR-7 compilant. You can obtain that stream calling the getBody() function.  Let's look into an example:  use Gishiki\\Core\\Route;\nuse Gishiki\\Logging\\Logger;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //get the body stream\n    $body = $request- getBody();\n\n    //rewind the stream (aka reset the cursor at the beginning of the stream)\n    $body- rewind();\n\n    //read the entire request body\n    $request =  ;\n    while (!$body- eof()) {\n        $request .= read(1);\n    }\n\n    //have fun with your request body!\n});  I know what you are thinking... You could parse that request body to obtain\nsomething like an array or a class that you can use within your application....  Well, if that's the case you may appreciate the fact that Gishiki does this\nin your place!  To trigger the request body automatic parsing you can use the getParsedBody()\nfunction that triggers the better parser for the given 'Content-type' header!", 
            "title": "Request Body"
        }, 
        {
            "location": "/usage/response/", 
            "text": "Response\n\n\nThe \nGishiki\\HttpKernel\\Response\n class is used to fully represent an HTTP response.\n\n\nThe Response class is PSR-7 conformant and follows that specification sheet.\n\n\nEach \nRequest\n triggers the generation of a response.\n\n\nThat response is automatically sent back to the client at the end of the\napplication lifetime.\n\n\nThe main target of an application is \nediting\n that response before the departure\nof that response.\n\n\nAn HTTP response is made of two parts:\n\n\n\n\nResponse \nheader\n \n\n\nResponse \nbody\n\n\n\n\nThose parts and steps to generate them are described later on this document.\n\n\nResponse Header\n\n\nEvery HTTP response \nMUST\n contains an header.\n\n\nAn HTTP header have a bare minimum structure that comprises the HTTP revision,\nthe status code and the message associated to the status code.\n\n\nSince each status code have its own predefined status phrase (like 404 not found,\n500 internal server error, 200 OK and so on) when the status code is changed the\nstatus phrase is automatically changed by the framework.\n\n\nThat can be done calling the \nwithStatus\n function:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //the response code - phrase will be 404 - Not Found\n    $response-\nwithStatus(404);\n});\n\n\n\n\nYou can manually change the status phrase, but you are discouraged from doing such\nthing with standard status code!\n\n\nWhat you can do is using it to send a strong signal to a bad client:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/complex\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    //numberOfRequests is the number of requests that a client has sent today\n    if ($numberOfRequests \n 5) {\n        //perform the complex operation (may stress the system)\n        action();\n    } else {\n        //stop flooding my servers!\n        $response-\nwithStatus(666, 'FUCK YOU!');\n    }\n});\n\n\n\n\nSorry for the bad language, that was only intended to help me to give you a (real :D)\nexample of usage.\n\n\nResponse Header Details\n\n\nEach response can contains a lot of details about itselfs like the length of the\ncontent or the type of the content.\n\n\nEach 'response detail' is a collection of values binded to a key which is the name\nof the property.\n\n\nIn order to edit the value of a property you have to use the \nwithHeader\n function:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/complex\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $request-\nwithHeader('Cache-Control', 'no-store, no-cache, must-revalidate');\n});\n\n\n\n\nIf you are unsure on how to use this feature you should read more about http response \nheader\n.\n\n\nResponse Body\n\n\nThe body of the response is the main part of the response: the \ncontent\n of the\nresponse.\n\n\nFor example if the response is an html content the response body is what the\nuser calls \nthe webpage\n.\n\n\nTo directly modify the response body you can use the \nwrite\n function:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $content = \nEOT\n\nhtml\n\n    \nhead\n\n        \ntitle\nMy webpage\n/title\n\n    \n/head\n\n    \nbody\n\n        \nh1\nMy webpage\n/h1\n\n        \np\nHello, this is my personal webpage!\n/p\n\n    \n/body\n\n\n/html\n\nEOT;\n\n    //write the response\n    $response-\nwithHeader('Content-Type', 'text/html');\n    $response-\nwrite($content);\n});\n\n\n\n\nThis is a simple example to Gishiki used to generate an html response,\nhowever since Gishiki is built to be used as the foundation of RESTful services\nthe response body shoild be a JSON, XML, YAML etc... content.\n\n\nTo generate a response body from a serializable data collection Gishiki provides\na function that automate this process: this function is called \nsetSerializedBody\n\nand does more than just converting a collection to a fixed format:\n\n\nuse Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(\n/factorial/{int:integer}\n,\n    function (Request $request, Response \n$response, SerializableCollection \n$arguments)\n{\n    $x = $arguments-\nint;\n    $factorial = fact($x);\n\n    $data = new SerializableCollection([\n        'timestamp' =\n time(),\n        'result'    =\n $factorial,\n    ]);\n\n    $response-\nsetSerializedBody($data);\n});\n\n\n\n\nThe given collection may be serialized to a JSON content, XML content or YAML content.\nYou may decide the content type by setting the header 'Content-Type' \nBUT THAT IS A WASTE OF TIME\n:\nGishiki \nAUTOMAGICALLY\n uses the content type listening for client preferences.\n\n\nThis means that a client is not enforced to be able to deserialize a specific\ncontent type, but can choose the preferred content-type including it on the\nhttp request header using the 'Accept' property!\n\n\nFollowing accept values are used to request a specific data serialization format:\n\n\n\n\n'text/yaml'            -\n YAML\n\n\n'text/x-yaml'          -\n YAML\n\n\n'application/yaml'     -\n YAML\n\n\n'application/x-yaml'   -\n XML\n\n\n'application/xml'      -\n XML\n\n\n'text/xml'             -\n XML\n\n\n'application/json'     -\n JSON\n\n\n\n\nAnything else triggers the default serialization format, which is JSON!", 
            "title": "Response"
        }, 
        {
            "location": "/usage/response/#response", 
            "text": "The  Gishiki\\HttpKernel\\Response  class is used to fully represent an HTTP response.  The Response class is PSR-7 conformant and follows that specification sheet.  Each  Request  triggers the generation of a response.  That response is automatically sent back to the client at the end of the\napplication lifetime.  The main target of an application is  editing  that response before the departure\nof that response.  An HTTP response is made of two parts:   Response  header    Response  body   Those parts and steps to generate them are described later on this document.", 
            "title": "Response"
        }, 
        {
            "location": "/usage/response/#response-header", 
            "text": "Every HTTP response  MUST  contains an header.  An HTTP header have a bare minimum structure that comprises the HTTP revision,\nthe status code and the message associated to the status code.  Since each status code have its own predefined status phrase (like 404 not found,\n500 internal server error, 200 OK and so on) when the status code is changed the\nstatus phrase is automatically changed by the framework.  That can be done calling the  withStatus  function:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any(Route::NOT_FOUND,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //the response code - phrase will be 404 - Not Found\n    $response- withStatus(404);\n});  You can manually change the status phrase, but you are discouraged from doing such\nthing with standard status code!  What you can do is using it to send a strong signal to a bad client:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /complex ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    //numberOfRequests is the number of requests that a client has sent today\n    if ($numberOfRequests   5) {\n        //perform the complex operation (may stress the system)\n        action();\n    } else {\n        //stop flooding my servers!\n        $response- withStatus(666, 'FUCK YOU!');\n    }\n});  Sorry for the bad language, that was only intended to help me to give you a (real :D)\nexample of usage.", 
            "title": "Response Header"
        }, 
        {
            "location": "/usage/response/#response-header-details", 
            "text": "Each response can contains a lot of details about itselfs like the length of the\ncontent or the type of the content.  Each 'response detail' is a collection of values binded to a key which is the name\nof the property.  In order to edit the value of a property you have to use the  withHeader  function:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /complex ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $request- withHeader('Cache-Control', 'no-store, no-cache, must-revalidate');\n});  If you are unsure on how to use this feature you should read more about http response  header .", 
            "title": "Response Header Details"
        }, 
        {
            "location": "/usage/response/#response-body", 
            "text": "The body of the response is the main part of the response: the  content  of the\nresponse.  For example if the response is an html content the response body is what the\nuser calls  the webpage .  To directly modify the response body you can use the  write  function:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( / ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $content =  EOT html \n     head \n         title My webpage /title \n     /head \n     body \n         h1 My webpage /h1 \n         p Hello, this is my personal webpage! /p \n     /body  /html \nEOT;\n\n    //write the response\n    $response- withHeader('Content-Type', 'text/html');\n    $response- write($content);\n});  This is a simple example to Gishiki used to generate an html response,\nhowever since Gishiki is built to be used as the foundation of RESTful services\nthe response body shoild be a JSON, XML, YAML etc... content.  To generate a response body from a serializable data collection Gishiki provides\na function that automate this process: this function is called  setSerializedBody \nand does more than just converting a collection to a fixed format:  use Gishiki\\Core\\Route;\nuse Gishiki\\HttpKernel\\Request;\nuse Gishiki\\HttpKernel\\Response;\nuse Gishiki\\Algorithms\\Collections\\SerializableCollection;\n\nRoute::any( /factorial/{int:integer} ,\n    function (Request $request, Response  $response, SerializableCollection  $arguments)\n{\n    $x = $arguments- int;\n    $factorial = fact($x);\n\n    $data = new SerializableCollection([\n        'timestamp' =  time(),\n        'result'    =  $factorial,\n    ]);\n\n    $response- setSerializedBody($data);\n});  The given collection may be serialized to a JSON content, XML content or YAML content.\nYou may decide the content type by setting the header 'Content-Type'  BUT THAT IS A WASTE OF TIME :\nGishiki  AUTOMAGICALLY  uses the content type listening for client preferences.  This means that a client is not enforced to be able to deserialize a specific\ncontent type, but can choose the preferred content-type including it on the\nhttp request header using the 'Accept' property!  Following accept values are used to request a specific data serialization format:   'text/yaml'            -  YAML  'text/x-yaml'          -  YAML  'application/yaml'     -  YAML  'application/x-yaml'   -  XML  'application/xml'      -  XML  'text/xml'             -  XML  'application/json'     -  JSON   Anything else triggers the default serialization format, which is JSON!", 
            "title": "Response Body"
        }, 
        {
            "location": "/usage/logging/", 
            "text": "Logging\n\n\nGishiki comes with a simple and small logging library that may use different logging\ntechnologies like the UNIX logging daemon (and its emulation on Windows).\n\n\nThe logger included in Gishiki is PSR-3 compilant and is super-simple to setup and use!\n\n\nGetting a logger\n\n\nWithin Gishiki each time you want to store a log entry a logger object is required.\n\n\nThe logger object is derived from the Gishiki\\Logging\\Logger class.\n\n\nWhen creating a new instance of the logger class you may and may not pass\n(to the class constructor) a string that identify the method used to store log entries.\n\n\nIf you don't pass an URL to the newly created Logger instance than the default one\nwill be used (see \nconfiguration\n for an example of configuration\nwith \"autolog\" set to null).\n\n\nConnection\n\n\nThe connection string is an URL with the following structure:\n\n\nadapter://resource\n\n\n\n\nWhen the adapter is the adapter used to access the resource and the resource is specific\nwith one adapter.\n\n\nAt the moment supported adapters are:\n\n\n\n\nfile\n\n\ngelf\n\n\nstream\n\n\nsyslog\n\n\nnull\n\n\n\n\nA valid example can be:\n\n\n$logger = new Gishiki\\Logger\\Logging(\nfile://logs.txt\n);\n\n\n\n\nYou need to read the correct sub-character of the page to understand how to identify the\nresource to be used.\n\n\nFile\n\n\nIf a file is used to register log entries the resource is given as a path to the file.\n\n\nThe file MUST be accessible with write permissions to php.\n\n\nThe file path can either be given as a relative path or an absolute file.\n\n\nfile:///var/logs/myApp.log\n\n\n\n\nthis will store the log in the /var/logs/myApp.log file.\n\n\nSyslog\n\n\nIf you want the Unix syslogd service to be responsible for log management than the\nconfiguration string must be something like:\n\n\nsyslog://myAppName\n\n\n\n\nWhere myAppName is the name of your application.\n\n\nThis is particularly useful if you want to be able to entirely customize the \nlog management process or avoid file-write permission problems.\n\n\nStream\n\n\nSometimes, due to the system configuration, you may want to save your logs on stdout,\nstderr or a memory stream.\n\n\nstream://\nstream_name\n\n\n\n\n\nThe \nstream name\n can be one of the following:\n\n\n\n\nstdout\n\n\nstderr\n\n\nstdmem\n\n\n\n\nGraylog\n\n\nIf you have an active graylog server you can send log entries to that server by\nenstabilishing a connection using a query like:\n\n\ngelf://\nprotocol\n:\nhostname\n:\nport\n\n\n\n\n\nWhere \nprotocol\n can be either \nUDP\n or \nTCP\n.\n\n\nWriting a log entry\n\n\nTo send a log entry you must call the \nlog\n function.\n\n\nThe first argument is the level of severity, it can be one of the following:\n\n\n\n\n\\Psr\\Log\\LogLevel::EMERGENCY -\n 'emergency'\n\n\n\\Psr\\Log\\LogLevel::ALERT -\n 'alert'\n\n\n\\Psr\\Log\\LogLevel::CRITICAL -\n 'critical'\n\n\n\\Psr\\Log\\LogLevel::ERROR -\n 'error'\n\n\n\\Psr\\Log\\LogLevel::WARNING -\n 'warning'\n\n\n\\Psr\\Log\\LogLevel::NOTICE -\n 'notice'\n\n\n\\Psr\\Log\\LogLevel::INFO -\n 'info'\n\n\n\\Psr\\Log\\LogLevel::DEBUG -\n 'debug'\n\n\n\n\nyou can use either the string or the contant provided by the psr package (suggested).\n\n\nThe second argument is the message, and the third argument is a collection of\ndetails as a simple PHP array:\n\n\n$logger = new Logger(\ngelf://\nprotocol\n:\nhostname\n:\nport\n);\n$logger-\nlog(\\Psr\\Log\\LogLevel::EMERGENCY, \nEnvironmental temperature too high\n, [\n        'temperature' =\n 56.7,\n    ]);\n\n\n\n\nWith stream and file adapters the collection of values are a sobstitution mask\nfor the message:\n\n\n$logger = new Logger(\nstream://stdout\n);\n$logger-\nlog(\\Psr\\Log\\LogLevel::EMERGENCY, \nEnvironmental temperature too high: {{temperature}} \u00b0C\n, [\n        'temperature' =\n 56.7,\n    ]);\n\n\n\n\nThat code will print out the string \"Environmental temperature too high: 56.7 \u00b0C\"\nas a result.\n\n\nSpecialized Writers\n\n\nIt is possible (permitted by the PSR-3 standard) to call a specialized function\nthat identify itselfs the severity of the log entry, those functions are called\nlike the severity to be used:\n\n\n$logger = new Logger(\nstream://stdout\n);\n$logger-\nemergency(\nEnvironmental temperature too high: {{temperature}} \u00b0C\n, [\n        'temperature' =\n 56.7,\n    ]);\n\n\n\n\nThe complete list of those functions is:\n\n\n\n\nemergency\n\n\nalert\n\n\ncritical\n\n\nerror\n\n\nwarning\n\n\nnotice\n\n\ninfo\n\n\ndebug", 
            "title": "Logger"
        }, 
        {
            "location": "/usage/logging/#logging", 
            "text": "Gishiki comes with a simple and small logging library that may use different logging\ntechnologies like the UNIX logging daemon (and its emulation on Windows).  The logger included in Gishiki is PSR-3 compilant and is super-simple to setup and use!", 
            "title": "Logging"
        }, 
        {
            "location": "/usage/logging/#getting-a-logger", 
            "text": "Within Gishiki each time you want to store a log entry a logger object is required.  The logger object is derived from the Gishiki\\Logging\\Logger class.  When creating a new instance of the logger class you may and may not pass\n(to the class constructor) a string that identify the method used to store log entries.  If you don't pass an URL to the newly created Logger instance than the default one\nwill be used (see  configuration  for an example of configuration\nwith \"autolog\" set to null).", 
            "title": "Getting a logger"
        }, 
        {
            "location": "/usage/logging/#connection", 
            "text": "The connection string is an URL with the following structure:  adapter://resource  When the adapter is the adapter used to access the resource and the resource is specific\nwith one adapter.  At the moment supported adapters are:   file  gelf  stream  syslog  null   A valid example can be:  $logger = new Gishiki\\Logger\\Logging( file://logs.txt );  You need to read the correct sub-character of the page to understand how to identify the\nresource to be used.", 
            "title": "Connection"
        }, 
        {
            "location": "/usage/logging/#file", 
            "text": "If a file is used to register log entries the resource is given as a path to the file.  The file MUST be accessible with write permissions to php.  The file path can either be given as a relative path or an absolute file.  file:///var/logs/myApp.log  this will store the log in the /var/logs/myApp.log file.", 
            "title": "File"
        }, 
        {
            "location": "/usage/logging/#syslog", 
            "text": "If you want the Unix syslogd service to be responsible for log management than the\nconfiguration string must be something like:  syslog://myAppName  Where myAppName is the name of your application.  This is particularly useful if you want to be able to entirely customize the \nlog management process or avoid file-write permission problems.", 
            "title": "Syslog"
        }, 
        {
            "location": "/usage/logging/#stream", 
            "text": "Sometimes, due to the system configuration, you may want to save your logs on stdout,\nstderr or a memory stream.  stream:// stream_name   The  stream name  can be one of the following:   stdout  stderr  stdmem", 
            "title": "Stream"
        }, 
        {
            "location": "/usage/logging/#graylog", 
            "text": "If you have an active graylog server you can send log entries to that server by\nenstabilishing a connection using a query like:  gelf:// protocol : hostname : port   Where  protocol  can be either  UDP  or  TCP .", 
            "title": "Graylog"
        }, 
        {
            "location": "/usage/logging/#writing-a-log-entry", 
            "text": "To send a log entry you must call the  log  function.  The first argument is the level of severity, it can be one of the following:   \\Psr\\Log\\LogLevel::EMERGENCY -  'emergency'  \\Psr\\Log\\LogLevel::ALERT -  'alert'  \\Psr\\Log\\LogLevel::CRITICAL -  'critical'  \\Psr\\Log\\LogLevel::ERROR -  'error'  \\Psr\\Log\\LogLevel::WARNING -  'warning'  \\Psr\\Log\\LogLevel::NOTICE -  'notice'  \\Psr\\Log\\LogLevel::INFO -  'info'  \\Psr\\Log\\LogLevel::DEBUG -  'debug'   you can use either the string or the contant provided by the psr package (suggested).  The second argument is the message, and the third argument is a collection of\ndetails as a simple PHP array:  $logger = new Logger( gelf:// protocol : hostname : port );\n$logger- log(\\Psr\\Log\\LogLevel::EMERGENCY,  Environmental temperature too high , [\n        'temperature' =  56.7,\n    ]);  With stream and file adapters the collection of values are a sobstitution mask\nfor the message:  $logger = new Logger( stream://stdout );\n$logger- log(\\Psr\\Log\\LogLevel::EMERGENCY,  Environmental temperature too high: {{temperature}} \u00b0C , [\n        'temperature' =  56.7,\n    ]);  That code will print out the string \"Environmental temperature too high: 56.7 \u00b0C\"\nas a result.", 
            "title": "Writing a log entry"
        }, 
        {
            "location": "/usage/logging/#specialized-writers", 
            "text": "It is possible (permitted by the PSR-3 standard) to call a specialized function\nthat identify itselfs the severity of the log entry, those functions are called\nlike the severity to be used:  $logger = new Logger( stream://stdout );\n$logger- emergency( Environmental temperature too high: {{temperature}} \u00b0C , [\n        'temperature' =  56.7,\n    ]);  The complete list of those functions is:   emergency  alert  critical  error  warning  notice  info  debug", 
            "title": "Specialized Writers"
        }, 
        {
            "location": "/usage/database/", 
            "text": "Database\n\n\nGishiki is developed to reflect the MVC pattern: this means that the data lifecycle\nis a foundamental characteristic within the framework!\n\n\nData persistence, coherence and integrity is managed by the database manager.\n\n\nTo connect a database manager you have to edit the active \nconfiguration\n.\n\n\nThere isn't a limit to the number of database connection, but each one \nMUST\n\nhave a name, and there \nCANNOT\n be two connections with the same name.\n\n\nConnecting Database\n\n\nA database connection have the following form:\n\n\nadapter://adapter_manageable_conenction_query\n\n\n\n\nwhere the connection query is a string that the adapter can parse.\n\n\nMongoDB\n\n\nA MongoDB connection can be enstabilished by using the mongodb adapter bundled\nwith Gishiki.\n\n\nThe MongoDB adapter uses the mongodb php native extension: Composer calls it\n\next-mongodb\n: \n\n\nmongodb://username:password@host:port/dbname\n\n\n\n\nDifferences between databases\n\n\nEach database manager has different characteristics: Gishiki aims to preserve\nstrong points of each one, but miracles are not possibles: everything comes to\na price.\n\n\nFollowing are \nRULES\n you \nMUST\n follow when designing database tables.\n\n\n\n\nThe name must be the plural form of the name of object to store\n\n\nThe name must be written in underscore_case with no UPPER characters\n\n\nThe unique id field (when possible) must be called _id\n\n\n\n\nOperations on Databases\n\n\nTo understand how to interact with the database you have to read the \nCRUD\n\nchapter of this tutorial.", 
            "title": "Database"
        }, 
        {
            "location": "/usage/database/#database", 
            "text": "Gishiki is developed to reflect the MVC pattern: this means that the data lifecycle\nis a foundamental characteristic within the framework!  Data persistence, coherence and integrity is managed by the database manager.  To connect a database manager you have to edit the active  configuration .  There isn't a limit to the number of database connection, but each one  MUST \nhave a name, and there  CANNOT  be two connections with the same name.", 
            "title": "Database"
        }, 
        {
            "location": "/usage/database/#connecting-database", 
            "text": "A database connection have the following form:  adapter://adapter_manageable_conenction_query  where the connection query is a string that the adapter can parse.", 
            "title": "Connecting Database"
        }, 
        {
            "location": "/usage/database/#mongodb", 
            "text": "A MongoDB connection can be enstabilished by using the mongodb adapter bundled\nwith Gishiki.  The MongoDB adapter uses the mongodb php native extension: Composer calls it ext-mongodb :   mongodb://username:password@host:port/dbname", 
            "title": "MongoDB"
        }, 
        {
            "location": "/usage/database/#differences-between-databases", 
            "text": "Each database manager has different characteristics: Gishiki aims to preserve\nstrong points of each one, but miracles are not possibles: everything comes to\na price.  Following are  RULES  you  MUST  follow when designing database tables.   The name must be the plural form of the name of object to store  The name must be written in underscore_case with no UPPER characters  The unique id field (when possible) must be called _id", 
            "title": "Differences between databases"
        }, 
        {
            "location": "/usage/database/#operations-on-databases", 
            "text": "To understand how to interact with the database you have to read the  CRUD \nchapter of this tutorial.", 
            "title": "Operations on Databases"
        }, 
        {
            "location": "/usage/CRUD/", 
            "text": "CRUD\n\n\nThe acronym \nCRUD\n stands for Create, Read, Update and Delete: those are names\nof main operations you will be allowed (directly or indirectly) to perform on\ndatabases that are supporting your application.\n\n\nNotice that:\n if you only need read permissions from a database such as\nPostgreSQL or MySQL, you do \nNOT\n need to use an user with full access.\n\n\nCreate\n\n\nThe creation of a new \ndocument\n/\nrow\n either starts from a \nCollectionInterface\n,\nsuch as \nSerializableCollection\n or a native PHP array.\n\n\nThe function that has to be called is \ncreate\n that also requires the name of\nthe \ntable\n/\ncollection\n to be affected:\n\n\nuse Gishiki\\Database\\DatabaseManager;\n\n$connection = DatabaseManager::retrieve('connectionName');\n\n$idOfNewDocument = $connection-\ncreate('tbname', new SerializableCollection([\n    'name'      =\n $name,\n    'surname'   =\n $surname,\n    'nickname'  =\n $nickname,\n    'password'  =\n $hash //it is NOT good to store plain passwords\n]));\n\n\n\n\nWhere the name of the connection is the same name in the application \nconfiguration\n.\n\n\nDelete\n\n\nTo delete a restricted set of \ndocuments\n/\nrows\n from a \ntable\n/\ncollection\n\nyou have to call, on the desired database connection the \ndelete\n function.\n\n\nThe delete function needs the name of the table/collection to be affected and\na valid instance of SelectionCriteria:\n\n\nuse Gishiki\\Database\\DatabaseManager;\nuse Gishiki\\Database\\Runtime\\SelectionCriteria;\nuse Gishiki\\Database\\Runtime\\FieldRelation;\n\n$connection = DatabaseManager::retrieve('connectionName');\n\n$connection-\ndelete('tbname', SelectionCriteria::select([\n            'nickname' =\n $nickname\n        ])-\nor_where('email', FieldRelation::EQUAL, $email)\n    );\n\n\n\n\nYou can also delete \nEVERY\n \ndocuments\n/\nrows\n from a \ntable\n/\ncollection\n\nusing the \ndeleteAll\n function.\n\n\nThe delete function only needs the name of the table/collection to be affected:\n\n\nuse Gishiki\\Database\\DatabaseManager;\nuse Gishiki\\Database\\Runtime\\SelectionCriteria;\nuse Gishiki\\Database\\Runtime\\FieldRelation;\n\n$connection = DatabaseManager::retrieve('connectionName');\n\n$connection-\ndeleteAll('tbname');\n\n\n\n\nNote that:\n calling the delete function, passing an empty SelectionCriteria\nobject has the same effect of calling deleteAll, however deleteAll will perform\na little better!", 
            "title": "CRUD"
        }, 
        {
            "location": "/usage/CRUD/#crud", 
            "text": "The acronym  CRUD  stands for Create, Read, Update and Delete: those are names\nof main operations you will be allowed (directly or indirectly) to perform on\ndatabases that are supporting your application.  Notice that:  if you only need read permissions from a database such as\nPostgreSQL or MySQL, you do  NOT  need to use an user with full access.", 
            "title": "CRUD"
        }, 
        {
            "location": "/usage/CRUD/#create", 
            "text": "The creation of a new  document / row  either starts from a  CollectionInterface ,\nsuch as  SerializableCollection  or a native PHP array.  The function that has to be called is  create  that also requires the name of\nthe  table / collection  to be affected:  use Gishiki\\Database\\DatabaseManager;\n\n$connection = DatabaseManager::retrieve('connectionName');\n\n$idOfNewDocument = $connection- create('tbname', new SerializableCollection([\n    'name'      =  $name,\n    'surname'   =  $surname,\n    'nickname'  =  $nickname,\n    'password'  =  $hash //it is NOT good to store plain passwords\n]));  Where the name of the connection is the same name in the application  configuration .", 
            "title": "Create"
        }, 
        {
            "location": "/usage/CRUD/#delete", 
            "text": "To delete a restricted set of  documents / rows  from a  table / collection \nyou have to call, on the desired database connection the  delete  function.  The delete function needs the name of the table/collection to be affected and\na valid instance of SelectionCriteria:  use Gishiki\\Database\\DatabaseManager;\nuse Gishiki\\Database\\Runtime\\SelectionCriteria;\nuse Gishiki\\Database\\Runtime\\FieldRelation;\n\n$connection = DatabaseManager::retrieve('connectionName');\n\n$connection- delete('tbname', SelectionCriteria::select([\n            'nickname' =  $nickname\n        ])- or_where('email', FieldRelation::EQUAL, $email)\n    );  You can also delete  EVERY   documents / rows  from a  table / collection \nusing the  deleteAll  function.  The delete function only needs the name of the table/collection to be affected:  use Gishiki\\Database\\DatabaseManager;\nuse Gishiki\\Database\\Runtime\\SelectionCriteria;\nuse Gishiki\\Database\\Runtime\\FieldRelation;\n\n$connection = DatabaseManager::retrieve('connectionName');\n\n$connection- deleteAll('tbname');  Note that:  calling the delete function, passing an empty SelectionCriteria\nobject has the same effect of calling deleteAll, however deleteAll will perform\na little better!", 
            "title": "Delete"
        }, 
        {
            "location": "/cli/", 
            "text": "CLI Toolkit\n\n\nGishiki uses a CLI toolkit to speed up development and code generation.\n\n\nThe executable resides under the ./vendor/bin/ directory, and is called\ngishiki.\n\n\nIt accept an arbitrary number of arguments, but the first one is the action\nyou want to perform:\n\n\n./vendor/bin/gishiki \naction\n [param 1] [param2] [param3] #and so on.....\n\n\n\n\nThe number of parameters following the action depends on the action you want to\nperform.\n\n\nApplication Creation\n\n\nTo bootstrap a new application the command is fixed:\n\n\n./vendor/bin/gishiki new application\n\n\n\n\nThis will create a basic and empty application that uses an sqlite3 database,\nhas a randomly-generated RSA private key, and is ready to be executed.\n\n\nController Creation\n\n\nTo bootstrap a new controller the command requires controller name:\n\n\n./vendor/bin/gishiki new controller ControllerName\n\n\n\n\nThis will create a basic controller with a small example piece of code.", 
            "title": "CLI Toolkit"
        }, 
        {
            "location": "/cli/#cli-toolkit", 
            "text": "Gishiki uses a CLI toolkit to speed up development and code generation.  The executable resides under the ./vendor/bin/ directory, and is called\ngishiki.  It accept an arbitrary number of arguments, but the first one is the action\nyou want to perform:  ./vendor/bin/gishiki  action  [param 1] [param2] [param3] #and so on.....  The number of parameters following the action depends on the action you want to\nperform.", 
            "title": "CLI Toolkit"
        }, 
        {
            "location": "/cli/#application-creation", 
            "text": "To bootstrap a new application the command is fixed:  ./vendor/bin/gishiki new application  This will create a basic and empty application that uses an sqlite3 database,\nhas a randomly-generated RSA private key, and is ready to be executed.", 
            "title": "Application Creation"
        }, 
        {
            "location": "/cli/#controller-creation", 
            "text": "To bootstrap a new controller the command requires controller name:  ./vendor/bin/gishiki new controller ControllerName  This will create a basic controller with a small example piece of code.", 
            "title": "Controller Creation"
        }, 
        {
            "location": "/license/", 
            "text": "Apache License\n\n\nVersion 2.0, January 2004\n\n\nhttp://www.apache.org/licenses/\n\n\nTerms and Conditions for use, reproduction, and distribution\n\n\n1. Definitions\n\n\n\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.\n\n\n\u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.\n\n\n\u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \u201ccontrol\u201d means \n(i)\n the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or \n(ii)\n ownership of fifty percent (50%) or more of the\noutstanding shares, or \n(iii)\n beneficial ownership of such entity.\n\n\n\u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising\npermissions granted by this License.\n\n\n\u201cSource\u201d form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.\n\n\n\u201cObject\u201d form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.\n\n\n\u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).\n\n\n\u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.\n\n\n\u201cContribution\u201d shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\u201csubmitted\u201d means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \u201cNot a Contribution.\u201d\n\n\n\u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.\n\n\n2. Grant of Copyright License\n\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable copyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the Work and such\nDerivative Works in Source or Object form.\n\n\n3. Grant of Patent License\n\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable (except as stated in this section) patent license to make, have\nmade, use, offer to sell, sell, import, and otherwise transfer the Work, where\nsuch license applies only to those patent claims licensable by such Contributor\nthat are necessarily infringed by their Contribution(s) alone or by combination\nof their Contribution(s) with the Work to which such Contribution(s) was\nsubmitted. If You institute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work or a\nContribution incorporated within the Work constitutes direct or contributory\npatent infringement, then any patent licenses granted to You under this License\nfor that Work shall terminate as of the date such litigation is filed.\n\n\n4. Redistribution\n\n\nYou may reproduce and distribute copies of the Work or Derivative Works thereof\nin any medium, with or without modifications, and in Source or Object form,\nprovided that You meet the following conditions:\n\n\n\n\n(a)\n You must give any other recipients of the Work or Derivative Works a copy of\nthis License; and\n\n\n(b)\n You must cause any modified files to carry prominent notices stating that You\nchanged the files; and\n\n\n(c)\n You must retain, in the Source form of any Derivative Works that You distribute,\nall copyright, patent, trademark, and attribution notices from the Source form\nof the Work, excluding those notices that do not pertain to any part of the\nDerivative Works; and\n\n\n(d)\n If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any\nDerivative Works that You distribute must include a readable copy of the\nattribution notices contained within such NOTICE file, excluding those notices\nthat do not pertain to any part of the Derivative Works, in at least one of the\nfollowing places: within a NOTICE text file distributed as part of the\nDerivative Works; within the Source form or documentation, if provided along\nwith the Derivative Works; or, within a display generated by the Derivative\nWorks, if and wherever such third-party notices normally appear. The contents of\nthe NOTICE file are for informational purposes only and do not modify the\nLicense. You may add Your own attribution notices within Derivative Works that\nYou distribute, alongside or as an addendum to the NOTICE text from the Work,\nprovided that such additional attribution notices cannot be construed as\nmodifying the License.\n\n\n\n\nYou may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License.\n\n\n5. Submission of Contributions\n\n\nUnless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.\n\n\n6. Trademarks\n\n\nThis License does not grant permission to use the trade names, trademarks,\nservice marks, or product names of the Licensor, except as required for\nreasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.\n\n\n7. Disclaimer of Warranty\n\n\nUnless required by applicable law or agreed to in writing, Licensor provides the\nWork (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,\nincluding, without limitation, any warranties or conditions of TITLE,\nNON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are\nsolely responsible for determining the appropriateness of using or\nredistributing the Work and assume any risks associated with Your exercise of\npermissions under this License.\n\n\n8. Limitation of Liability\n\n\nIn no event and under no legal theory, whether in tort (including negligence),\ncontract, or otherwise, unless required by applicable law (such as deliberate\nand grossly negligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special, incidental,\nor consequential damages of any character arising as a result of this License or\nout of the use or inability to use the Work (including but not limited to\ndamages for loss of goodwill, work stoppage, computer failure or malfunction, or\nany and all other commercial damages or losses), even if such Contributor has\nbeen advised of the possibility of such damages.\n\n\n9. Accepting Warranty or Additional Liability\n\n\nWhile redistributing the Work or Derivative Works thereof, You may choose to\noffer, and charge a fee for, acceptance of support, warranty, indemnity, or\nother liability obligations and/or rights consistent with this License. However,\nin accepting such obligations, You may act only on Your own behalf and on Your\nsole responsibility, not on behalf of any other Contributor, and only if You\nagree to indemnify, defend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason of your\naccepting any such warranty or additional liability.\n\n\nEND OF TERMS AND CONDITIONS\n\n\nAPPENDIX: How to apply the Apache License to your work\n\n\nTo apply the Apache License to your work, attach the following boilerplate\nnotice, with the fields enclosed by brackets \n[]\n replaced with your own\nidentifying information. (Don't include the brackets!) The text should be\nenclosed in the appropriate comment syntax for the file format. We also\nrecommend that a file or class name and description of purpose be included on\nthe same \u201cprinted page\u201d as the copyright notice for easier identification within\nthird-party archives.\n\n\nCopyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }, 
        {
            "location": "/license/#apache-license", 
            "text": "Version 2.0, January 2004  http://www.apache.org/licenses/", 
            "title": "Apache License"
        }, 
        {
            "location": "/license/#terms-and-conditions-for-use-reproduction-and-distribution", 
            "text": "", 
            "title": "Terms and Conditions for use, reproduction, and distribution"
        }, 
        {
            "location": "/license/#1-definitions", 
            "text": "\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.  \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.  \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \u201ccontrol\u201d means  (i)  the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or  (ii)  ownership of fifty percent (50%) or more of the\noutstanding shares, or  (iii)  beneficial ownership of such entity.  \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising\npermissions granted by this License.  \u201cSource\u201d form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.  \u201cObject\u201d form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.  \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).  \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.  \u201cContribution\u201d shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\u201csubmitted\u201d means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \u201cNot a Contribution.\u201d  \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.", 
            "title": "1. Definitions"
        }, 
        {
            "location": "/license/#2-grant-of-copyright-license", 
            "text": "Subject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable copyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the Work and such\nDerivative Works in Source or Object form.", 
            "title": "2. Grant of Copyright License"
        }, 
        {
            "location": "/license/#3-grant-of-patent-license", 
            "text": "Subject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable (except as stated in this section) patent license to make, have\nmade, use, offer to sell, sell, import, and otherwise transfer the Work, where\nsuch license applies only to those patent claims licensable by such Contributor\nthat are necessarily infringed by their Contribution(s) alone or by combination\nof their Contribution(s) with the Work to which such Contribution(s) was\nsubmitted. If You institute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work or a\nContribution incorporated within the Work constitutes direct or contributory\npatent infringement, then any patent licenses granted to You under this License\nfor that Work shall terminate as of the date such litigation is filed.", 
            "title": "3. Grant of Patent License"
        }, 
        {
            "location": "/license/#4-redistribution", 
            "text": "You may reproduce and distribute copies of the Work or Derivative Works thereof\nin any medium, with or without modifications, and in Source or Object form,\nprovided that You meet the following conditions:   (a)  You must give any other recipients of the Work or Derivative Works a copy of\nthis License; and  (b)  You must cause any modified files to carry prominent notices stating that You\nchanged the files; and  (c)  You must retain, in the Source form of any Derivative Works that You distribute,\nall copyright, patent, trademark, and attribution notices from the Source form\nof the Work, excluding those notices that do not pertain to any part of the\nDerivative Works; and  (d)  If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any\nDerivative Works that You distribute must include a readable copy of the\nattribution notices contained within such NOTICE file, excluding those notices\nthat do not pertain to any part of the Derivative Works, in at least one of the\nfollowing places: within a NOTICE text file distributed as part of the\nDerivative Works; within the Source form or documentation, if provided along\nwith the Derivative Works; or, within a display generated by the Derivative\nWorks, if and wherever such third-party notices normally appear. The contents of\nthe NOTICE file are for informational purposes only and do not modify the\nLicense. You may add Your own attribution notices within Derivative Works that\nYou distribute, alongside or as an addendum to the NOTICE text from the Work,\nprovided that such additional attribution notices cannot be construed as\nmodifying the License.   You may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License.", 
            "title": "4. Redistribution"
        }, 
        {
            "location": "/license/#5-submission-of-contributions", 
            "text": "Unless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.", 
            "title": "5. Submission of Contributions"
        }, 
        {
            "location": "/license/#6-trademarks", 
            "text": "This License does not grant permission to use the trade names, trademarks,\nservice marks, or product names of the Licensor, except as required for\nreasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.", 
            "title": "6. Trademarks"
        }, 
        {
            "location": "/license/#7-disclaimer-of-warranty", 
            "text": "Unless required by applicable law or agreed to in writing, Licensor provides the\nWork (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,\nincluding, without limitation, any warranties or conditions of TITLE,\nNON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are\nsolely responsible for determining the appropriateness of using or\nredistributing the Work and assume any risks associated with Your exercise of\npermissions under this License.", 
            "title": "7. Disclaimer of Warranty"
        }, 
        {
            "location": "/license/#8-limitation-of-liability", 
            "text": "In no event and under no legal theory, whether in tort (including negligence),\ncontract, or otherwise, unless required by applicable law (such as deliberate\nand grossly negligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special, incidental,\nor consequential damages of any character arising as a result of this License or\nout of the use or inability to use the Work (including but not limited to\ndamages for loss of goodwill, work stoppage, computer failure or malfunction, or\nany and all other commercial damages or losses), even if such Contributor has\nbeen advised of the possibility of such damages.", 
            "title": "8. Limitation of Liability"
        }, 
        {
            "location": "/license/#9-accepting-warranty-or-additional-liability", 
            "text": "While redistributing the Work or Derivative Works thereof, You may choose to\noffer, and charge a fee for, acceptance of support, warranty, indemnity, or\nother liability obligations and/or rights consistent with this License. However,\nin accepting such obligations, You may act only on Your own behalf and on Your\nsole responsibility, not on behalf of any other Contributor, and only if You\nagree to indemnify, defend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason of your\naccepting any such warranty or additional liability.  END OF TERMS AND CONDITIONS", 
            "title": "9. Accepting Warranty or Additional Liability"
        }, 
        {
            "location": "/license/#appendix-how-to-apply-the-apache-license-to-your-work", 
            "text": "To apply the Apache License to your work, attach the following boilerplate\nnotice, with the fields enclosed by brackets  []  replaced with your own\nidentifying information. (Don't include the brackets!) The text should be\nenclosed in the appropriate comment syntax for the file format. We also\nrecommend that a file or class name and description of purpose be included on\nthe same \u201cprinted page\u201d as the copyright notice for easier identification within\nthird-party archives.  Copyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "APPENDIX: How to apply the Apache License to your work"
        }
    ]
}